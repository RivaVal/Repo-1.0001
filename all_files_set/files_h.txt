

//========================================
//  –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª CommonTypes.h
//========================================
// CommonTypes.h
#pragma once

#include <Arduino.h>
#include <cstdint>

// ================== –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• ==================
#pragma pack(push, 1)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö
struct DataComSet_t {
    uint8_t  preamble[2];    // 0xAA 0x55
    uint16_t packet_id;      // –°—á–µ—Ç—á–∏–∫ –ø–∞–∫–µ—Ç–æ–≤
    uint8_t  comUp;          // 0-255
    uint8_t  comLeft;        // 0-255
    uint16_t comThrottle;    // 1000-2000
    uint8_t  comParashut;    // 0/1
    uint32_t timestamp;      // –í—Ä–µ–º—è –∏–∑ millis()
    uint8_t  comSetAll;      // –ë–∏—Ç–æ–≤–∞—è –º–∞—Å–∫–∞
    uint8_t  crc8;           // –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Å—É–º–º–∞
};

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏
struct AckPacket_t {
    uint8_t preamble[2];        // 0x55 0xAA
    uint16_t packet_id;         // ID –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º–æ–≥–æ –ø–∞–∫–µ—Ç–∞
    uint32_t timestamp;         // –í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∞–∫–µ—Ç–∞
    uint8_t status;             // –°—Ç–∞—Ç—É—Å –ø–æ–ª—É—á–µ–Ω–∏—è
    uint8_t crc8;               // –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Å—É–º–º–∞
};

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–∞ ICM-20948
struct SensorData {
    uint32_t timestamp;
    float accel[3];      // x, y, z –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä (g)
    float gyro[3];       // x, y, z –≥–∏—Ä–æ—Å–∫–æ–ø (dps)
    float mag[3];        // x, y, z –º–∞–≥–Ω–∏—Ç–æ–º–µ—Ç—Ä (uT)
    float euler[3];      // roll, pitch, yaw —É–≥–ª—ã (–≥—Ä–∞–¥—É—Å—ã)
    float quat[4];       // –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω
    uint8_t status;      // —Å—Ç–∞—Ç—É—Å DMP
};

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª—è
struct ModuleStats_t {
    uint32_t tx_packets;
    uint32_t rx_packets;
    uint32_t crc_errors;
    uint32_t tx_errors;
    uint32_t rx_errors;
    int16_t last_rssi;
    uint32_t resets;
    uint32_t reconnects;
    uint32_t aux_timeouts;
    uint32_t busy_errors;
    uint32_t not_ready_errors;
    uint32_t connection_lost_events;
    uint32_t receive_timeouts;
    uint16_t preamble_errors;
};

#pragma pack(pop)

// ================== –ü–ï–†–ï–ß–ò–°–õ–ï–ù–ò–Ø ==================
// –°–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã
enum class SystemState {
    BOOT,           // –ó–∞–≥—Ä—É–∑–∫–∞
    INITIALIZING,   // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    STANDBY,        // –û–∂–∏–¥–∞–Ω–∏–µ
    ACTIVE,         // –ê–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    ERROR,          // –û—à–∏–±–∫–∞
    RECOVERY        // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
};

// –°—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–π –º–æ–¥—É–ª—è E49
enum class EbyteStatus {
    SUCCESS,
    ERROR_INIT,
    ERROR_SEND,
    ERROR_RECEIVE,
    ERROR_CRC,
    ERROR_AUX_TIMEOUT,
    ERROR_NO_NEW_DATA,
    ERROR_INVALID_DATA,
    ERROR_INVALID_PREAMBLE,
    ERROR_PREAMBLE,
    ERROR_SEND_FAILED,
    ERROR_RECEIVE_FAILED,
    ERROR_MODULE_NOT_RESPONDING,
    ERROR_INVALID_STATE,
    ERROR_BUSY,
    ERROR_NOT_READY,
    ERROR_CONNECTION_LOST
};
/*
// –î–æ–±–∞–≤–∏—Ç—å –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–¥—ã –æ—à–∏–±–æ–∫
enum class EbyteStatus {
    SUCCESS,
    ERROR_AUX_TIMEOUT,
    ERROR_CRC,
    ERROR_PREAMBLE,
    ERROR_SEND_FAILED,
    ERROR_RECEIVE_FAILED,
    ERROR_MODULE_NOT_RESPONDING,
    ERROR_INVALID_STATE
    // ...
};
*/

// ================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ô –ö–õ–ê–°–° ==================
// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∏—Ç–æ–≤–æ–π –º–∞—Å–∫–æ–π
class BitMask {
private:
    uint8_t mask;
public:
    BitMask() : mask(0) {}
    explicit BitMask(uint8_t initialMask) : mask(initialMask) {}
    
    void setBit(uint8_t bit, bool value) {
        if (bit > 7) return;
        if (value) {
            mask |= (1 << bit);
        } else {
            mask &= ~(1 << bit);
        }
    }
    
    bool getBit(uint8_t bit) const {
        if (bit > 7) return false;
        return (mask & (1 << bit)) != 0;
    }

    uint8_t getMask() const { return mask; }
    void setMask(uint8_t newMask) { mask = newMask; }
};


// Config.h
#pragma once
//=======================================
//  –®–∞–≥ 1: –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª Config.h
//=======================================

#include <Arduino.h>
#include <driver/ledc.h>
#include "CommonTypes.h"  // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£

// ================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ü–ò–ù–û–í ==================
// –ü–∏–Ω—ã –º–æ–¥—É–ª—è E49
constexpr uint8_t E49_PIN_RX = 16;
constexpr uint8_t E49_PIN_TX = 17;
constexpr uint8_t E49_PIN_M0 = 4;
constexpr uint8_t E49_PIN_M1 = 21;
constexpr uint8_t E49_PIN_AUX = 5;

// SPI –ø–∏–Ω—ã
constexpr uint8_t SPI_ICM_CS  = 22;
constexpr uint8_t SPI_SD_CS   = 33;
constexpr uint8_t SPI_ICM_INT = 32;
constexpr uint8_t LED_PIN = 2;

// SPI –ø–∏–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
constexpr uint8_t VSPI_SCLK = 18;
constexpr uint8_t VSPI_MISO = 19;
constexpr uint8_t VSPI_MOSI = 23;

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
constexpr int servoPins[] = {12, 13, 14, 27, 26};
constexpr ledc_channel_t servoChannels[] = {
    LEDC_CHANNEL_0,
    LEDC_CHANNEL_1,
    LEDC_CHANNEL_2,
    LEDC_CHANNEL_3,
    LEDC_CHANNEL_4
};

// ================== –ü–ê–†–ê–ú–ï–¢–†–´ –°–í–Ø–ó–ò E49 ==================
constexpr uint32_t E49_BAUDRATE = 9600;
constexpr uint8_t E49_ADDRESS_H = 1;
constexpr uint8_t E49_ADDRESS_L = 101;
constexpr uint8_t E49_CHANNEL = 0x17;

// ================== –¢–ê–ô–ú–ê–£–¢–´ –ò –ò–ù–¢–ï–†–í–ê–õ–´ ==================
constexpr uint16_t AUX_TIMEOUT_MS = 300;
constexpr uint16_t ACK_TIMEOUT_MS = 500;
constexpr uint16_t RECEIVE_TIMEOUT_MS = 1000;
constexpr uint32_t RECONNECT_INTERVAL_MS = 2000;
constexpr uint32_t CONNECTION_TIMEOUT_MS = 5000;
constexpr uint8_t MAX_RETRIES = 3;

constexpr uint32_t LED_BLINK_INTERVAL_MS = 100;
constexpr uint32_t STATS_INTERVAL_MS = 15000;

// ================== –ü–ê–†–ê–ú–ï–¢–†–´ –ü–ê–ö–ï–¢–û–í ==================
constexpr uint8_t CRC8_POLYNOMIAL = 0x07;
constexpr uint8_t PACKET_PREAMBLE_1 = 0xAA;
constexpr uint8_t PACKET_PREAMBLE_2 = 0x55;
constexpr uint8_t ACK_PREAMBLE_1 = 0x55;
constexpr uint8_t ACK_PREAMBLE_2 = 0xAA;
constexpr uint8_t COM_SETALL_MASK = 0b00000001;

// ================== –†–ê–ó–ú–ï–†–´ –°–¢–†–£–ö–¢–£–† ==================
constexpr uint8_t DATA_COM_SET_SIZE = 19; // sizeof(DataComSet_t)
constexpr uint8_t ACK_PACKET_SIZE = 11;   // sizeof(AckPacket_t)

// ================== –°–ò–°–¢–ï–ú–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ==================
constexpr uint32_t STATUS_UPDATE_INTERVAL = 5000;
constexpr uint32_t ICM_READ_INTERVAL = 20;
constexpr uint32_t SD_WRITE_INTERVAL = 100;
constexpr uint32_t RADIO_PROCESS_INTERVAL = 50;
constexpr uint32_t ERROR_CHECK_INTERVAL = 1000;

//===========================================================

extern int servoAngles[5];
extern int servoTargetAngles[5];

        // GlobalVars.cpp:
        //      #include "GlobalVars.h"
int angles[5] = {90, 90, 90, 90, 0};
int targetAngles[5] = {90, 90, 90, 90, 0};




//====================================================================
//	2. –§–∞–π–ª E49_Controller.h
//====================================================================
//  2. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π E49_Controller.h
//

#ifndef E49_CONTROLLER_H
#define E49_CONTROLLER_H

#include <Arduino.h>
#include <HardwareSerial.h>
#include <EBYTE.h>
//  #include "Config.h"
#include "Config.h"  // ‚Üê –ò–ó–ú–ï–ù–ò–¢–¨ –° E49_Config.h –Ω–∞ Config.h


class E49_Controller {
public:
    // –°–æ—Å—Ç–æ—è–Ω–∏—è –∫–æ–Ω–µ—á–Ω–æ–≥–æ –∞–≤—Ç–æ–º–∞—Ç–∞
    enum class InternalState {
        IDLE,
        WAITING_FOR_AUX,
        SENDING_DATA,
        WAITING_FOR_ACK,
        RECEIVING_DATA,
        PROCESSING_DATA,
        SENDING_ACK,
        RESETTING,
        ERROR
    };

    E49_Controller(bool isSender, HardwareSerial* serial = &Serial2);
    ~E49_Controller();
    
    // –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è
    E49_Controller(const E49_Controller&) = delete;
    E49_Controller& operator=(const E49_Controller&) = delete;

    EbyteStatus init();
    EbyteStatus sendData(const DataComSet_t& data);
    EbyteStatus receiveData(DataComSet_t& data);
    EbyteStatus checkConnection();
    EbyteStatus reinitialize();
    void process();
    
    // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –º–µ—Ç–æ–¥—ã
    EbyteStatus startSendingData(const DataComSet_t& data);
    EbyteStatus startReceivingData();
    
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    DataComSet_t createTestPacket() const;
    void printStats() const;
    void printStatus(EbyteStatus status) const;
    void enableDebug(bool enable);
    void forceRecovery();
    
    // –ì–µ—Ç—Ç–µ—Ä—ã
    InternalState getInternalState() const { return _internalState; }
    bool isConnectionLost() const;
    const ModuleStats_t& getStats() const { return _stats; }
    
private:
    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–µ—Ç–æ–¥—ã
    uint8_t calculateCRC8(const uint8_t* data, size_t length) const;
    EbyteStatus waitForAux(uint32_t timeout = AUX_TIMEOUT_MS);
    EbyteStatus sendAck(uint16_t packet_id, uint8_t status);
    EbyteStatus receiveAck(AckPacket_t& ack);
    void resetModule();
    bool attemptRecovery();
    bool testCommunication();
    void handleConnectionRecovery();
    void updateLED();
    void changeState(InternalState newState);
    
    // –ü–æ–ª—è –∫–ª–∞—Å—Å–∞
    EBYTE* _transceiver;
    bool _isSender;
    bool _debugEnabled;
    ModuleStats_t _stats;
    uint32_t _lastActivityTime;
    uint32_t _lastReconnectAttempt;
    bool _ledState;
    uint32_t _lastLedToggle;
    
    // –ö–æ–Ω–µ—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç
    InternalState _internalState;
    uint32_t _stateStartTime;
    DataComSet_t _currentTxPacket;
    DataComSet_t _currentRxPacket;
    AckPacket_t _currentAckPacket;
    uint8_t _currentRetry;
    
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è
    uint32_t _lastResetTime;
    uint32_t _lastSaveTime;    
};

#endif // E49_CONTROLLER_H




//=========================================================
//  Eleron_Controller.h 
//===========================================================
//  üìã –ü–æ–ª–Ω–∞—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è:
//  Eleron_Controller.h
//
#pragma once
#include <Arduino.h>
#include "Config.h"
                //  #include "servo_config.h"

// Eleron_Controller.h - –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
class EleronController {
private:
    static const uint32_t UPDATE_INTERVAL = 20;
    static uint32_t last_update_time;
    static int current_angles[5];
    static bool test_running;
    static uint32_t test_start_time;
    static uint8_t test_phase;

public:
    static void begin();
    static void update(const SensorData& data);
    static const int* getCurrentAngles() { return current_angles; }
    
    static void setNeutralPosition();
    static void startTestSequence();
    static void stopTestSequence();
    static bool isTestRunning() { return test_running; }

private:
    static void processIMUData(const SensorData& data);
    static void setServoAngle(uint8_t channel, int angle);
    static void runTestSequence();
    static void smoothServoMovement();
};

    //============================================
    //   3. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π ICM_Handler.h
    //============================================
    //  üöÄ –£–ª—É—á—à–µ–Ω–∏—è —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π –¥–∞–Ω–Ω—ã—Ö:
    //  5. ICM_Handler.h - –î–æ–±–∞–≤–ª—è–µ–º –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—é
    //  cpp

#pragma once
#include <Arduino.h>
#include <SPI.h>
#include <cstdint>
#include "Config.h"
#include "SPI_Manager.h"

class ICMHandler {
private:
    static const uint32_t READ_INTERVAL = 20;
    static const size_t BUFFER_SIZE = 100; // –ë—É—Ñ–µ—Ä –Ω–∞ 100 –∏–∑–º–µ—Ä–µ–Ω–∏–π
    
    static uint32_t last_read_time;
    static SensorData current_data;
    static uint32_t read_count;
    static uint32_t error_count;
    
    // –ë—É—Ñ–µ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å—å—é –Ω–∞ SD
    static SensorData data_buffer[BUFFER_SIZE];
    static size_t buffer_index;
    static bool buffer_overflow;

public:
    static bool begin();
    static bool readData();
    static const SensorData& getData();
    static bool isDataFresh();
    static uint32_t getReadCount();
    static uint32_t getErrorCount();
    
    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±—É—Ñ–µ—Ä–æ–º
    static bool addToBuffer(const SensorData& data);
    static size_t getBufferSize() { return buffer_index; }
    static bool isBufferFull() { return buffer_index >= BUFFER_SIZE; }
    static bool isBufferOverflow() { return buffer_overflow; }
    static const SensorData* getBuffer() { return data_buffer; }
    static void clearBuffer() { buffer_index = 0; buffer_overflow = false; }
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—É—Ñ–µ—Ä–∞
    static size_t getBufferCapacity() { return BUFFER_SIZE; }
    static float getBufferUsage() { return (float)buffer_index / BUFFER_SIZE * 100.0f; }
};

//=============================================================================
//==============    ( motor_controller.h )  ===================================
//=============================================================================




//=============================================================================
//=============================================================================
//=============================================================================
//  –ü–†–ò–í–ï–¢!! –û–∫—Ä—É–∂–µ–Ω–∏–µ: Arduino IDE, –º–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä esp32, –º–æ—Ç–æ—Ä—ã –±–µ–∑ –¥—Ä–∞–π–≤–µ—Ä–æ–≤, 
//  —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –æ—Ç ESP32 , –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–≤–∞ –ø–∏–Ω–∞ –¥–ª—è –¥–≤—É—Ö –º–æ—Ç–æ—Ä–æ–≤: GPIO25 –¥–ª—è 
//  –º–æ—Ç–æ—Ä–∞_–ê –∏ GPIO26 –¥–ª—è –º–æ—Ç–æ—Ä–∞_–ë ,–º–æ—Ç–æ—Ä—ã –ø–∏—Ç–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ —Ä–µ–≥—É–ª—è—Ç–æ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏ BLHeli 
//  EMAX ESC –æ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –ø–∏—Ç–∞–Ω–∏—è: 21V, 6500 mAh    –ü—Ä–æ—à—É  –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ 
//  –ø—Ä–æ–µ–∫—Ç–∞ –∏–∑ github, –ø—Ä–æ—à—É –Ω–∞ –æ—Å–Ω–æ–≤–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–æ–∂–¥—É–ª–µ–π, –¥–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç –ú–û–î–£–õ–Ø 
//  —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤—É–º—è –º–æ—Ç–æ—Ä–∞–º–∏ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º–æ—Ç–æ—Ä–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É: QX Motor QF(2827) 2227-1800KV 
//  –±–µ–∑ –¥—Ä–∞–π–≤–µ—Ä–∞, –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç—É–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ mcpwm, –ù–£–ñ–ï–ù –≤–∞—Ä–∏–∞–Ω—Ç –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π 
//  –º–æ–∂–Ω–æ –≤–ø–∏—Å–∞—Ç—å –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–Ω—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–æ–µ–∫—Ç–∞! –ü—Ä–æ—à—É –¥–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç –∫–æ–¥–∞ —Å –ø–æ–ª–Ω–æ–π 
//  –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π –∏ –ø–æ–¥—Ä–æ–±–Ω—ã–º –æ–ø–∏—Å–∞–Ω–∏–µ–º, –∞ —Ç–∞–∫ –∂–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–æ–≥–æ–Ω–∞ 
//  –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π:
//  1.–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–±–æ—Ç—ã –ø—Ä–∏ —Ç–µ—Å—Ç–æ–≤–æ–º –ø—Ä–æ–≥–æ–Ω–µ:
//  2. –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –º–æ—Ç–æ—Ä–æ–≤ –¥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
//  3. –†–∞–±–æ—Ç–∞ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º —É—Ä–æ–≤–Ω–µ –≤ —Ç–µ—á–µ–Ω–∏–µ 4 –º–∏–Ω—É—Ç
//  4. –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—Ç–æ—Ä–æ–≤ !
//  
//  –ü—Ä–∏–≤–µ—Ç! –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª –≤–∞—à –ø—Ä–æ–µ–∫—Ç. –í–æ—Ç –º–æ–¥—É–ª—å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏ —á–µ—Ä–µ–∑ 
//  ESC —Å —Ç–µ—Å—Ç–æ–≤—ã–º –ø—Ä–æ–≥–æ–Ω–æ–º:
//  –ú–æ–¥—É–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏ —á–µ—Ä–µ–∑ ESC (motor_controller.h)
//  
//=============================================================================
//=============================================================================
//=============================================================================
//  / * *
//   * –ú–æ–¥—É–ª—å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤—É–º—è –º–æ—Ç–æ—Ä–∞–º–∏ QX Motor QF(2827) 2227-1800KV
//   * —á–µ—Ä–µ–∑ ESC —Ä–µ–≥—É–ª—è—Ç–æ—Ä—ã BLHeli EMAX —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–≥–æ MCPWM Prelude API.
//   * –¢–æ–ª—å–∫–æ –¥–≤–∏–∂–µ–Ω–∏–µ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É.
//   * –í–µ—Ä—Å–∏—è: 2.0.0 (—Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º MCPWM Prelude)
//   * 
//   * –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: 
//   * - GPIO25 -> ESC –º–æ—Ç–æ—Ä–∞ A
//   * - GPIO26 -> ESC –º–æ—Ç–æ—Ä–∞ B  
//   * –ü–∏—Ç–∞–Ω–∏–µ: 21V, 6500mAh
//  
//   * /
//   *   ( motor_controller.h )
//   *
//   *
//   * –¢–æ–ª—å–∫–æ –¥–≤–∏–∂–µ–Ω–∏–µ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É.
//   * –í–µ—Ä—Å–∏—è: 2.0.1 (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏)
//   * /
//==============================================================
//	üìÑ motor_controller.h (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π)
//==============================================================
//  üìÑ motor_controller.h (–µ–¥–∏–Ω—ã–π —Ñ–∞–π–ª)
//==============================================================
//üìÑ motor_controller.h (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
//==============================================================  

#ifndef MOTOR_CONTROLLER_H
#define MOTOR_CONTROLLER_H

#include <Arduino.h>
#include <driver/mcpwm_prelude.h>

class MotorController {
private:
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–∏–Ω–æ–≤ ESC
    static const uint8_t ESC_A_PIN = 25;
    static const uint8_t ESC_B_PIN = 26;
    
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã ESC
    static const int ESC_MIN_US = 1000;
    static const int ESC_MAX_US = 2000;
    static const int PWM_FREQUENCY = 50;
    
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–æ–≥–æ–Ω–∞
    static const int TEST_SPEED_PERCENT = 70;
    static const int TEST_DURATION_SEC = 240;
    
    // MCPWM –æ–±—ä–µ–∫—Ç—ã
    mcpwm_timer_handle_t timer_a = nullptr;
    mcpwm_timer_handle_t timer_b = nullptr;
    mcpwm_oper_handle_t oper_a = nullptr;
    mcpwm_oper_handle_t oper_b = nullptr;
    mcpwm_cmpr_handle_t comparator_a = nullptr;
    mcpwm_cmpr_handle_t comparator_b = nullptr;
    mcpwm_gen_handle_t generator_a = nullptr;
    mcpwm_gen_handle_t generator_b = nullptr;
    
    // –¢–µ–∫—É—â–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –º–æ—Ç–æ—Ä–æ–≤
    int current_speed_a;
    int current_speed_b;
    
    // –§–ª–∞–≥–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    bool is_test_running;
    unsigned long test_start_time;
    unsigned long last_report_time;
    
    // –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    void init_mcpwm_components();
    void setup_generator_actions();
    void safe_delete(mcpwm_timer_handle_t& handle);
    void safe_delete(mcpwm_oper_handle_t& handle);
    void safe_delete(mcpwm_cmpr_handle_t& handle);
    void safe_delete(mcpwm_gen_handle_t& handle);
    
    int percent_to_us(int speed_percent) const;
    uint32_t us_to_ticks(int us) const;
    bool set_motor_speed(char motor_id, int speed_percent);
    void ramp_speed(int target_speed, float duration);

public:
    MotorController();
    ~MotorController();
    
    bool init_esc();
    bool set_motors_speed(int speed, float ramp_time = 0);
    void stop_motors(float ramp_time = 0);
    bool start_test_sequence();
    void stop_test_sequence();
    String get_motors_status() const;
    bool is_test_active() const;
    void update();
};

extern MotorController motor_controller;

#endif


    //=======================================================
    //  3. –ú–û–î–£–õ–¨ ‚Ññ3: SD Card Handler (SD_Handler.h)
    //=======================================================
    //  cpp
    //
    //  üöÄ –£–ª—É—á—à–µ–Ω–∏—è —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π –∏ –ø—Ä–æ–≤–µ—Ä–∫–æ–π –º–µ—Å—Ç–∞:
    //  5. SD_Handler.h - –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –±—É—Ñ–µ—Ä–æ–º
    //cpp

#pragma once
#include "SPI_Manager.h"
#include "Config.h"
#include <SD.h>

class SDHandler {
private:
    static const uint32_t WRITE_INTERVAL = 500;
    static const size_t BUFFER_SIZE = 2048; // 2KB –±—É—Ñ–µ—Ä
    static const uint32_t MIN_FREE_SPACE = 1024 * 1024; // 1MB –º–∏–Ω–∏–º–∞–ª—å–Ω–æ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞
    
    static uint32_t last_write_time;
    static uint32_t last_flush_time;
    static File data_file;
    static bool sd_initialized;
    
    // –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
    static uint8_t write_buffer[BUFFER_SIZE];
    static size_t buffer_index;
    static uint32_t write_count;
    static uint32_t error_count;

public:
    static bool begin();
    static bool writeData(const SensorData& data);
    static void end();
    static bool isInitialized() { return sd_initialized; }
    
    // –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è
    static bool flushBuffer();
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞
    static bool checkFreeSpace();
    static uint64_t getFreeSpace();
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    static uint32_t getWriteCount() { return write_count; }
    static uint32_t getErrorCount() { return error_count; }
    static float getSuccessRate();
};


//====================================================================
//	2. –§–∞–π–ª SPI_Manager.h
//====================================================================
//  –ö–∞–∫ –∏ —Ç—Ä–µ–±–æ–≤–∞–ª–æ—Å—å, –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã.
//  –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
//  1. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π SPI_Manager.h
//
#pragma once
#include <Arduino.h>
#include <SPI.h>
#include "Config.h"

class SPIManager {
private:
    static bool spi_busy;
    static uint32_t last_operation_time;
    static uint8_t current_cs_pin;

public:
    static bool begin();
    static bool acquireForICM(uint32_t timeout = 5);
    static bool acquireForSD(uint32_t timeout = 50);
    static void release();
    static SPIClass& getSPI() { return SPI; }
    static bool isBusy() { return spi_busy; }
    static uint32_t getLastOpTime() { return last_operation_time; }

private:
    static bool acquireSPI(uint8_t cs_pin, uint32_t timeout);
};


//=====================================
//`–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π GlobalVars.h:
//=====================================

#pragma once

// GlobalVars.h
extern int servoAngles[5];
extern int servoTargetAngles[5];

//=======================================