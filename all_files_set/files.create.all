

//========================================
//  –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª CommonTypes.h
//========================================
// CommonTypes.h
#pragma once

#include <Arduino.h>
#include <cstdint>

// ================== –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• ==================
#pragma pack(push, 1)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö
struct DataComSet_t {
    uint8_t  preamble[2];    // 0xAA 0x55
    uint16_t packet_id;      // –°—á–µ—Ç—á–∏–∫ –ø–∞–∫–µ—Ç–æ–≤
    uint8_t  comUp;          // 0-255
    uint8_t  comLeft;        // 0-255
    uint16_t comThrottle;    // 1000-2000
    uint8_t  comParashut;    // 0/1
    uint32_t timestamp;      // –í—Ä–µ–º—è –∏–∑ millis()
    uint8_t  comSetAll;      // –ë–∏—Ç–æ–≤–∞—è –º–∞—Å–∫–∞
    uint8_t  crc8;           // –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Å—É–º–º–∞
};

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—á–∏
struct AckPacket_t {
    uint8_t preamble[2];        // 0x55 0xAA
    uint16_t packet_id;         // ID –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º–æ–≥–æ –ø–∞–∫–µ—Ç–∞
    uint32_t timestamp;         // –í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–∞–∫–µ—Ç–∞
    uint8_t status;             // –°—Ç–∞—Ç—É—Å –ø–æ–ª—É—á–µ–Ω–∏—è
    uint8_t crc8;               // –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Å—É–º–º–∞
};

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –¥–∞–Ω–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–∞ ICM-20948
struct SensorData {
    uint32_t timestamp;
    float accel[3];      // x, y, z –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä (g)
    float gyro[3];       // x, y, z –≥–∏—Ä–æ—Å–∫–æ–ø (dps)
    float mag[3];        // x, y, z –º–∞–≥–Ω–∏—Ç–æ–º–µ—Ç—Ä (uT)
    float euler[3];      // roll, pitch, yaw —É–≥–ª—ã (–≥—Ä–∞–¥—É—Å—ã)
    float quat[4];       // –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω
    uint8_t status;      // —Å—Ç–∞—Ç—É—Å DMP
};

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª—è
struct ModuleStats_t {
    uint32_t tx_packets;
    uint32_t rx_packets;
    uint32_t crc_errors;
    uint32_t tx_errors;
    uint32_t rx_errors;
    int16_t last_rssi;
    uint32_t resets;
    uint32_t reconnects;
    uint32_t aux_timeouts;
    uint32_t busy_errors;
    uint32_t not_ready_errors;
    uint32_t connection_lost_events;
    uint32_t receive_timeouts;
    uint16_t preamble_errors;
};

#pragma pack(pop)

// ================== –ü–ï–†–ï–ß–ò–°–õ–ï–ù–ò–Ø ==================
// –°–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã
enum class SystemState {
    BOOT,           // –ó–∞–≥—Ä—É–∑–∫–∞
    INITIALIZING,   // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    STANDBY,        // –û–∂–∏–¥–∞–Ω–∏–µ
    ACTIVE,         // –ê–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞
    ERROR,          // –û—à–∏–±–∫–∞
    RECOVERY        // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ
};

// –°—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–π –º–æ–¥—É–ª—è E49
enum class EbyteStatus {
    SUCCESS,
    ERROR_INIT,
    ERROR_SEND,
    ERROR_RECEIVE,
    ERROR_CRC,
    ERROR_AUX_TIMEOUT,
    ERROR_NO_NEW_DATA,
    ERROR_INVALID_DATA,
    ERROR_INVALID_PREAMBLE,
    ERROR_PREAMBLE,
    ERROR_SEND_FAILED,
    ERROR_RECEIVE_FAILED,
    ERROR_MODULE_NOT_RESPONDING,
    ERROR_INVALID_STATE,
    ERROR_BUSY,
    ERROR_NOT_READY,
    ERROR_CONNECTION_LOST
};
/*
// –î–æ–±–∞–≤–∏—Ç—å –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–¥—ã –æ—à–∏–±–æ–∫
enum class EbyteStatus {
    SUCCESS,
    ERROR_AUX_TIMEOUT,
    ERROR_CRC,
    ERROR_PREAMBLE,
    ERROR_SEND_FAILED,
    ERROR_RECEIVE_FAILED,
    ERROR_MODULE_NOT_RESPONDING,
    ERROR_INVALID_STATE
    // ...
};
*/

// ================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ô –ö–õ–ê–°–° ==================
// –ö–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∏—Ç–æ–≤–æ–π –º–∞—Å–∫–æ–π
class BitMask {
private:
    uint8_t mask;
public:
    BitMask() : mask(0) {}
    explicit BitMask(uint8_t initialMask) : mask(initialMask) {}
    
    void setBit(uint8_t bit, bool value) {
        if (bit > 7) return;
        if (value) {
            mask |= (1 << bit);
        } else {
            mask &= ~(1 << bit);
        }
    }
    
    bool getBit(uint8_t bit) const {
        if (bit > 7) return false;
        return (mask & (1 << bit)) != 0;
    }

    uint8_t getMask() const { return mask; }
    void setMask(uint8_t newMask) { mask = newMask; }
};


// Config.h
#pragma once
//=======================================
//  –®–∞–≥ 1: –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª Config.h
//=======================================

#include <Arduino.h>
#include <driver/ledc.h>
#include "CommonTypes.h"  // ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–£ –°–¢–†–û–ö–£

// ================== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ü–ò–ù–û–í ==================
// –ü–∏–Ω—ã –º–æ–¥—É–ª—è E49
constexpr uint8_t E49_PIN_RX = 16;
constexpr uint8_t E49_PIN_TX = 17;
constexpr uint8_t E49_PIN_M0 = 4;
constexpr uint8_t E49_PIN_M1 = 21;
constexpr uint8_t E49_PIN_AUX = 5;

// SPI –ø–∏–Ω—ã
constexpr uint8_t SPI_ICM_CS  = 22;
constexpr uint8_t SPI_SD_CS   = 33;
constexpr uint8_t SPI_ICM_INT = 32;
constexpr uint8_t LED_PIN = 2;

// SPI –ø–∏–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
constexpr uint8_t VSPI_SCLK = 18;
constexpr uint8_t VSPI_MISO = 19;
constexpr uint8_t VSPI_MOSI = 23;

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
constexpr int servoPins[] = {12, 13, 14, 27, 26};
constexpr ledc_channel_t servoChannels[] = {
    LEDC_CHANNEL_0,
    LEDC_CHANNEL_1,
    LEDC_CHANNEL_2,
    LEDC_CHANNEL_3,
    LEDC_CHANNEL_4
};

// ================== –ü–ê–†–ê–ú–ï–¢–†–´ –°–í–Ø–ó–ò E49 ==================
constexpr uint32_t E49_BAUDRATE = 9600;
constexpr uint8_t E49_ADDRESS_H = 1;
constexpr uint8_t E49_ADDRESS_L = 101;
constexpr uint8_t E49_CHANNEL = 0x17;

// ================== –¢–ê–ô–ú–ê–£–¢–´ –ò –ò–ù–¢–ï–†–í–ê–õ–´ ==================
constexpr uint16_t AUX_TIMEOUT_MS = 300;
constexpr uint16_t ACK_TIMEOUT_MS = 500;
constexpr uint16_t RECEIVE_TIMEOUT_MS = 1000;
constexpr uint32_t RECONNECT_INTERVAL_MS = 2000;
constexpr uint32_t CONNECTION_TIMEOUT_MS = 5000;
constexpr uint8_t MAX_RETRIES = 3;

constexpr uint32_t LED_BLINK_INTERVAL_MS = 100;
constexpr uint32_t STATS_INTERVAL_MS = 15000;

// ================== –ü–ê–†–ê–ú–ï–¢–†–´ –ü–ê–ö–ï–¢–û–í ==================
constexpr uint8_t CRC8_POLYNOMIAL = 0x07;
constexpr uint8_t PACKET_PREAMBLE_1 = 0xAA;
constexpr uint8_t PACKET_PREAMBLE_2 = 0x55;
constexpr uint8_t ACK_PREAMBLE_1 = 0x55;
constexpr uint8_t ACK_PREAMBLE_2 = 0xAA;
constexpr uint8_t COM_SETALL_MASK = 0b00000001;

// ================== –†–ê–ó–ú–ï–†–´ –°–¢–†–£–ö–¢–£–† ==================
constexpr uint8_t DATA_COM_SET_SIZE = 19; // sizeof(DataComSet_t)
constexpr uint8_t ACK_PACKET_SIZE = 11;   // sizeof(AckPacket_t)

// ================== –°–ò–°–¢–ï–ú–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ==================
constexpr uint32_t STATUS_UPDATE_INTERVAL = 5000;
constexpr uint32_t ICM_READ_INTERVAL = 20;
constexpr uint32_t SD_WRITE_INTERVAL = 100;
constexpr uint32_t RADIO_PROCESS_INTERVAL = 50;
constexpr uint32_t ERROR_CHECK_INTERVAL = 1000;

//===========================================================

extern int servoAngles[5];
extern int servoTargetAngles[5];

        // GlobalVars.cpp:
        //      #include "GlobalVars.h"
int angles[5] = {90, 90, 90, 90, 0};
int targetAngles[5] = {90, 90, 90, 90, 0};




//====================================================================
//	2. –§–∞–π–ª E49_Controller.h
//====================================================================
//  2. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π E49_Controller.h
//

#ifndef E49_CONTROLLER_H
#define E49_CONTROLLER_H

#include <Arduino.h>
#include <HardwareSerial.h>
#include <EBYTE.h>
//  #include "Config.h"
#include "Config.h"  // ‚Üê –ò–ó–ú–ï–ù–ò–¢–¨ –° E49_Config.h –Ω–∞ Config.h


class E49_Controller {
public:
    // –°–æ—Å—Ç–æ—è–Ω–∏—è –∫–æ–Ω–µ—á–Ω–æ–≥–æ –∞–≤—Ç–æ–º–∞—Ç–∞
    enum class InternalState {
        IDLE,
        WAITING_FOR_AUX,
        SENDING_DATA,
        WAITING_FOR_ACK,
        RECEIVING_DATA,
        PROCESSING_DATA,
        SENDING_ACK,
        RESETTING,
        ERROR
    };

    E49_Controller(bool isSender, HardwareSerial* serial = &Serial2);
    ~E49_Controller();
    
    // –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è
    E49_Controller(const E49_Controller&) = delete;
    E49_Controller& operator=(const E49_Controller&) = delete;

    EbyteStatus init();
    EbyteStatus sendData(const DataComSet_t& data);
    EbyteStatus receiveData(DataComSet_t& data);
    EbyteStatus checkConnection();
    EbyteStatus reinitialize();
    void process();
    
    // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∏–µ –º–µ—Ç–æ–¥—ã
    EbyteStatus startSendingData(const DataComSet_t& data);
    EbyteStatus startReceivingData();
    
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    DataComSet_t createTestPacket() const;
    void printStats() const;
    void printStatus(EbyteStatus status) const;
    void enableDebug(bool enable);
    void forceRecovery();
    
    // –ì–µ—Ç—Ç–µ—Ä—ã
    InternalState getInternalState() const { return _internalState; }
    bool isConnectionLost() const;
    const ModuleStats_t& getStats() const { return _stats; }
    
private:
    // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –º–µ—Ç–æ–¥—ã
    uint8_t calculateCRC8(const uint8_t* data, size_t length) const;
    EbyteStatus waitForAux(uint32_t timeout = AUX_TIMEOUT_MS);
    EbyteStatus sendAck(uint16_t packet_id, uint8_t status);
    EbyteStatus receiveAck(AckPacket_t& ack);
    void resetModule();
    bool attemptRecovery();
    bool testCommunication();
    void handleConnectionRecovery();
    void updateLED();
    void changeState(InternalState newState);
    
    // –ü–æ–ª—è –∫–ª–∞—Å—Å–∞
    EBYTE* _transceiver;
    bool _isSender;
    bool _debugEnabled;
    ModuleStats_t _stats;
    uint32_t _lastActivityTime;
    uint32_t _lastReconnectAttempt;
    bool _ledState;
    uint32_t _lastLedToggle;
    
    // –ö–æ–Ω–µ—á–Ω—ã–π –∞–≤—Ç–æ–º–∞—Ç
    InternalState _internalState;
    uint32_t _stateStartTime;
    DataComSet_t _currentTxPacket;
    DataComSet_t _currentRxPacket;
    AckPacket_t _currentAckPacket;
    uint8_t _currentRetry;
    
    // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è
    uint32_t _lastResetTime;
    uint32_t _lastSaveTime;    
};

#endif // E49_CONTROLLER_H




//=========================================================
//  Eleron_Controller.h 
//===========================================================
//  üìã –ü–æ–ª–Ω–∞—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è:
//  Eleron_Controller.h
//
#pragma once
#include <Arduino.h>
#include "Config.h"
                //  #include "servo_config.h"

// Eleron_Controller.h - –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
class EleronController {
private:
    static const uint32_t UPDATE_INTERVAL = 20;
    static uint32_t last_update_time;
    static int current_angles[5];
    static bool test_running;
    static uint32_t test_start_time;
    static uint8_t test_phase;

public:
    static void begin();
    static void update(const SensorData& data);
    static const int* getCurrentAngles() { return current_angles; }
    
    static void setNeutralPosition();
    static void startTestSequence();
    static void stopTestSequence();
    static bool isTestRunning() { return test_running; }

private:
    static void processIMUData(const SensorData& data);
    static void setServoAngle(uint8_t channel, int angle);
    static void runTestSequence();
    static void smoothServoMovement();
};

    //============================================
    //   3. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π ICM_Handler.h
    //============================================
    //  üöÄ –£–ª—É—á—à–µ–Ω–∏—è —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π –¥–∞–Ω–Ω—ã—Ö:
    //  5. ICM_Handler.h - –î–æ–±–∞–≤–ª—è–µ–º –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—é
    //  cpp

#pragma once
#include <Arduino.h>
#include <SPI.h>
#include <cstdint>
#include "Config.h"
#include "SPI_Manager.h"

class ICMHandler {
private:
    static const uint32_t READ_INTERVAL = 20;
    static const size_t BUFFER_SIZE = 100; // –ë—É—Ñ–µ—Ä –Ω–∞ 100 –∏–∑–º–µ—Ä–µ–Ω–∏–π
    
    static uint32_t last_read_time;
    static SensorData current_data;
    static uint32_t read_count;
    static uint32_t error_count;
    
    // –ë—É—Ñ–µ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –∑–∞–ø–∏—Å—å—é –Ω–∞ SD
    static SensorData data_buffer[BUFFER_SIZE];
    static size_t buffer_index;
    static bool buffer_overflow;

public:
    static bool begin();
    static bool readData();
    static const SensorData& getData();
    static bool isDataFresh();
    static uint32_t getReadCount();
    static uint32_t getErrorCount();
    
    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±—É—Ñ–µ—Ä–æ–º
    static bool addToBuffer(const SensorData& data);
    static size_t getBufferSize() { return buffer_index; }
    static bool isBufferFull() { return buffer_index >= BUFFER_SIZE; }
    static bool isBufferOverflow() { return buffer_overflow; }
    static const SensorData* getBuffer() { return data_buffer; }
    static void clearBuffer() { buffer_index = 0; buffer_overflow = false; }
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±—É—Ñ–µ—Ä–∞
    static size_t getBufferCapacity() { return BUFFER_SIZE; }
    static float getBufferUsage() { return (float)buffer_index / BUFFER_SIZE * 100.0f; }
};

//=============================================================================
//==============    ( motor_controller.h )  ===================================
//=============================================================================




//=============================================================================
//=============================================================================
//=============================================================================
//  –ü–†–ò–í–ï–¢!! –û–∫—Ä—É–∂–µ–Ω–∏–µ: Arduino IDE, –º–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä esp32, –º–æ—Ç–æ—Ä—ã –±–µ–∑ –¥—Ä–∞–π–≤–µ—Ä–æ–≤, 
//  —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –æ—Ç ESP32 , –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–≤–∞ –ø–∏–Ω–∞ –¥–ª—è –¥–≤—É—Ö –º–æ—Ç–æ—Ä–æ–≤: GPIO25 –¥–ª—è 
//  –º–æ—Ç–æ—Ä–∞_–ê –∏ GPIO26 –¥–ª—è –º–æ—Ç–æ—Ä–∞_–ë ,–º–æ—Ç–æ—Ä—ã –ø–∏—Ç–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ —Ä–µ–≥—É–ª—è—Ç–æ—Ä —Å–∫–æ—Ä–æ—Å—Ç–∏ BLHeli 
//  EMAX ESC –æ—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –ø–∏—Ç–∞–Ω–∏—è: 21V, 6500 mAh    –ü—Ä–æ—à—É  –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ 
//  –ø—Ä–æ–µ–∫—Ç–∞ –∏–∑ github, –ø—Ä–æ—à—É –Ω–∞ –æ—Å–Ω–æ–≤–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–æ–∂–¥—É–ª–µ–π, –¥–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç –ú–û–î–£–õ–Ø 
//  —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤—É–º—è –º–æ—Ç–æ—Ä–∞–º–∏ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º–æ—Ç–æ—Ä–æ–≤ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É: QX Motor QF(2827) 2227-1800KV 
//  –±–µ–∑ –¥—Ä–∞–π–≤–µ—Ä–∞, –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç—É–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ mcpwm, –ù–£–ñ–ï–ù –≤–∞—Ä–∏–∞–Ω—Ç –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π 
//  –º–æ–∂–Ω–æ –≤–ø–∏—Å–∞—Ç—å –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–Ω—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–æ–µ–∫—Ç–∞! –ü—Ä–æ—à—É –¥–∞—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç –∫–æ–¥–∞ —Å –ø–æ–ª–Ω–æ–π 
//  –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π –∏ –ø–æ–¥—Ä–æ–±–Ω—ã–º –æ–ø–∏—Å–∞–Ω–∏–µ–º, –∞ —Ç–∞–∫ –∂–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–æ–≥–æ–Ω–∞ 
//  –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π:
//  1.–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–±–æ—Ç—ã –ø—Ä–∏ —Ç–µ—Å—Ç–æ–≤–æ–º –ø—Ä–æ–≥–æ–Ω–µ:
//  2. –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –º–æ—Ç–æ—Ä–æ–≤ –¥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
//  3. –†–∞–±–æ—Ç–∞ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º —É—Ä–æ–≤–Ω–µ –≤ —Ç–µ—á–µ–Ω–∏–µ 4 –º–∏–Ω—É—Ç
//  4. –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—Ç–æ—Ä–æ–≤ !
//  
//  –ü—Ä–∏–≤–µ—Ç! –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª –≤–∞—à –ø—Ä–æ–µ–∫—Ç. –í–æ—Ç –º–æ–¥—É–ª—å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏ —á–µ—Ä–µ–∑ 
//  ESC —Å —Ç–µ—Å—Ç–æ–≤—ã–º –ø—Ä–æ–≥–æ–Ω–æ–º:
//  –ú–æ–¥—É–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏ —á–µ—Ä–µ–∑ ESC (motor_controller.h)
//  
//=============================================================================
//=============================================================================
//=============================================================================
//  / * *
//   * –ú–æ–¥—É–ª—å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤—É–º—è –º–æ—Ç–æ—Ä–∞–º–∏ QX Motor QF(2827) 2227-1800KV
//   * —á–µ—Ä–µ–∑ ESC —Ä–µ–≥—É–ª—è—Ç–æ—Ä—ã BLHeli EMAX —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–æ–≤–æ–≥–æ MCPWM Prelude API.
//   * –¢–æ–ª—å–∫–æ –¥–≤–∏–∂–µ–Ω–∏–µ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É.
//   * –í–µ—Ä—Å–∏—è: 2.0.0 (—Å –∞–∫—Ç—É–∞–ª—å–Ω—ã–º MCPWM Prelude)
//   * 
//   * –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: 
//   * - GPIO25 -> ESC –º–æ—Ç–æ—Ä–∞ A
//   * - GPIO26 -> ESC –º–æ—Ç–æ—Ä–∞ B  
//   * –ü–∏—Ç–∞–Ω–∏–µ: 21V, 6500mAh
//  
//   * /
//   *   ( motor_controller.h )
//   *
//   *
//   * –¢–æ–ª—å–∫–æ –¥–≤–∏–∂–µ–Ω–∏–µ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É.
//   * –í–µ—Ä—Å–∏—è: 2.0.1 (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏)
//   * /
//==============================================================
//	üìÑ motor_controller.h (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π)
//==============================================================
//  üìÑ motor_controller.h (–µ–¥–∏–Ω—ã–π —Ñ–∞–π–ª)
//==============================================================
//üìÑ motor_controller.h (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
//==============================================================  

#ifndef MOTOR_CONTROLLER_H
#define MOTOR_CONTROLLER_H

#include <Arduino.h>
#include <driver/mcpwm_prelude.h>

class MotorController {
private:
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–∏–Ω–æ–≤ ESC
    static const uint8_t ESC_A_PIN = 25;
    static const uint8_t ESC_B_PIN = 26;
    
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã ESC
    static const int ESC_MIN_US = 1000;
    static const int ESC_MAX_US = 2000;
    static const int PWM_FREQUENCY = 50;
    
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ø—Ä–æ–≥–æ–Ω–∞
    static const int TEST_SPEED_PERCENT = 70;
    static const int TEST_DURATION_SEC = 240;
    
    // MCPWM –æ–±—ä–µ–∫—Ç—ã
    mcpwm_timer_handle_t timer_a = nullptr;
    mcpwm_timer_handle_t timer_b = nullptr;
    mcpwm_oper_handle_t oper_a = nullptr;
    mcpwm_oper_handle_t oper_b = nullptr;
    mcpwm_cmpr_handle_t comparator_a = nullptr;
    mcpwm_cmpr_handle_t comparator_b = nullptr;
    mcpwm_gen_handle_t generator_a = nullptr;
    mcpwm_gen_handle_t generator_b = nullptr;
    
    // –¢–µ–∫—É—â–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ –º–æ—Ç–æ—Ä–æ–≤
    int current_speed_a;
    int current_speed_b;
    
    // –§–ª–∞–≥–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    bool is_test_running;
    unsigned long test_start_time;
    unsigned long last_report_time;
    
    // –ü—Ä–∏–≤–∞—Ç–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    void init_mcpwm_components();
    void setup_generator_actions();
    void safe_delete(mcpwm_timer_handle_t& handle);
    void safe_delete(mcpwm_oper_handle_t& handle);
    void safe_delete(mcpwm_cmpr_handle_t& handle);
    void safe_delete(mcpwm_gen_handle_t& handle);
    
    int percent_to_us(int speed_percent) const;
    uint32_t us_to_ticks(int us) const;
    bool set_motor_speed(char motor_id, int speed_percent);
    void ramp_speed(int target_speed, float duration);

public:
    MotorController();
    ~MotorController();
    
    bool init_esc();
    bool set_motors_speed(int speed, float ramp_time = 0);
    void stop_motors(float ramp_time = 0);
    bool start_test_sequence();
    void stop_test_sequence();
    String get_motors_status() const;
    bool is_test_active() const;
    void update();
};

extern MotorController motor_controller;

#endif


    //=======================================================
    //  3. –ú–û–î–£–õ–¨ ‚Ññ3: SD Card Handler (SD_Handler.h)
    //=======================================================
    //  cpp
    //
    //  üöÄ –£–ª—É—á—à–µ–Ω–∏—è —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π –∏ –ø—Ä–æ–≤–µ—Ä–∫–æ–π –º–µ—Å—Ç–∞:
    //  5. SD_Handler.h - –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –±—É—Ñ–µ—Ä–æ–º
    //cpp

#pragma once
#include "SPI_Manager.h"
#include "Config.h"
#include <SD.h>

class SDHandler {
private:
    static const uint32_t WRITE_INTERVAL = 500;
    static const size_t BUFFER_SIZE = 2048; // 2KB –±—É—Ñ–µ—Ä
    static const uint32_t MIN_FREE_SPACE = 1024 * 1024; // 1MB –º–∏–Ω–∏–º–∞–ª—å–Ω–æ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞
    
    static uint32_t last_write_time;
    static uint32_t last_flush_time;
    static File data_file;
    static bool sd_initialized;
    
    // –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
    static uint8_t write_buffer[BUFFER_SIZE];
    static size_t buffer_index;
    static uint32_t write_count;
    static uint32_t error_count;

public:
    static bool begin();
    static bool writeData(const SensorData& data);
    static void end();
    static bool isInitialized() { return sd_initialized; }
    
    // –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è
    static bool flushBuffer();
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞
    static bool checkFreeSpace();
    static uint64_t getFreeSpace();
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    static uint32_t getWriteCount() { return write_count; }
    static uint32_t getErrorCount() { return error_count; }
    static float getSuccessRate();
};


//====================================================================
//	2. –§–∞–π–ª SPI_Manager.h
//====================================================================
//  –ö–∞–∫ –∏ —Ç—Ä–µ–±–æ–≤–∞–ª–æ—Å—å, –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ç–µ—Å—Ç—ã.
//  –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
//  1. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π SPI_Manager.h
//
#pragma once
#include <Arduino.h>
#include <SPI.h>
#include "Config.h"

class SPIManager {
private:
    static bool spi_busy;
    static uint32_t last_operation_time;
    static uint8_t current_cs_pin;

public:
    static bool begin();
    static bool acquireForICM(uint32_t timeout = 5);
    static bool acquireForSD(uint32_t timeout = 50);
    static void release();
    static SPIClass& getSPI() { return SPI; }
    static bool isBusy() { return spi_busy; }
    static uint32_t getLastOpTime() { return last_operation_time; }

private:
    static bool acquireSPI(uint8_t cs_pin, uint32_t timeout);
};


//=====================================
//`–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π GlobalVars.h:
//=====================================

#pragma once

// GlobalVars.h
extern int servoAngles[5];
extern int servoTargetAngles[5];

//=======================================
/**================================================
 * @file ESP32_Air_Plane_0001.ino
 * @brief –û—Å–Ω–æ–≤–Ω–æ–π –º–æ–¥—É–ª—å —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ë–ü–õ–ê
 * @version 2.0
 * @date 2024
 *================================================
 * –°–∏—Å—Ç–µ–º–∞ –≤–∫–ª—é—á–∞–µ—Ç:
 * - –†–∞–¥–∏–æ–º–æ–¥—É–ª—å E49 –¥–ª—è –ø—Ä–∏–µ–º–∞ –∫–æ–º–∞–Ω–¥
 * - IMU ICM-20948 –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
 * - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–∞–º–∏ —ç–ª–µ—Ä–æ–Ω–æ–≤
 * - SD –∫–∞—Ä—Ç—É –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
 * - –°–∏—Å—Ç–µ–º—É –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
 */

#include <Arduino.h>
#include <SPI.h>
#include "SPI_Manager.h"
#include "ICM_Handler.h"
#include "SD_Handler.h"
#include "Eleron_Controller.h"
#include "E49_Controller.h"
#include "Config.h"

// ================== –°–ò–°–¢–ï–ú–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ==================


// ================== –°–ò–°–¢–ï–ú–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==================

SystemState systemState = SystemState::BOOT;
SystemState previousState = SystemState::BOOT;
uint32_t systemStartTime = 0;
uint32_t errorCount = 0;
uint32_t lastStatusPrint = 0;

// ================== –≠–ö–ó–ï–ú–ü–õ–Ø–†–´ –ú–û–î–£–õ–ï–ô ==================
E49_Controller radioReceiver(false, &Serial2);

// ================== –ü–†–û–¢–û–¢–ò–ü–´ –§–£–ù–ö–¶–ò–ô ==================
void initializeSystem();
void initializeAllPins();
void handleSystemState();
void processSensors();
void handleRadioCommunication();
void controlOutputs();
void logTelemetry();
void updateSystemStatus();
void handleEmergency();
void systemRecovery();
void printStatusReport();
void checkSystemHealth();

// ================== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ==================

//  1. –î–æ–±–∞–≤—å—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–∏–Ω–æ–≤ –≤ setup():
void initializeAllPins() {
  // –ü–∏–Ω—ã EBYTE
  pinMode(E49_PIN_M0, OUTPUT);
  pinMode(E49_PIN_M1, OUTPUT);
  pinMode(E49_PIN_AUX, INPUT);

  // SPI –ø–∏–Ω—ã
  pinMode(VSPI_SCLK, OUTPUT);
  pinMode(VSPI_MISO, INPUT);
  pinMode(VSPI_MOSI, OUTPUT);
  pinMode(SPI_ICM_CS, OUTPUT);
  pinMode(SPI_SD_CS, OUTPUT);
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∏–Ω—ã
  pinMode(SPI_ICM_INT, INPUT);

  // –ü–∏–Ω—ã —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
  for (int i = 0; i < 5; i++) {
    pinMode(servoPins[i], OUTPUT);
  }

  // –°–≤–µ—Ç–æ–¥–∏–æ–¥
  pinMode(LED_PIN, OUTPUT);


  Serial.println("All pins initialized");
}  // end  initializeAllPins()




void setup() {
    initializeAllPins();

    Serial.begin(115200);
    Serial2.begin(9600, SERIAL_8N1, E49_PIN_RX, E49_PIN_TX);
    
            // handleRadioCommunication();
    Serial.println("\n=== –°–ò–°–¢–ï–ú–ê –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ë–ü–õ–ê ===");
    Serial.println("–í–µ—Ä—Å–∏—è 2.0 - –ó–∞–ø—É—Å–∫...");
    
    initializeSystem();
    systemStartTime = millis();

    delay(1000);
}

void loop() {
    static uint32_t loopStart = millis();
    uint32_t currentTime = millis();
    handleRadioCommunication() ;
    handleSystemState();
    processSensors();
    controlOutputs();
    logTelemetry();
    updateSystemStatus();
    checkSystemHealth();
    
    // –°—Ç–∞–±–∏–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —Ü–∏–∫–ª–∞
    uint32_t processingTime = millis() - currentTime;
    if (processingTime < 10) {
        delay(10 - processingTime);
    }

    // –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    uint32_t loopTime = millis() - loopStart;
    if (loopTime > 50) {  // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –µ—Å–ª–∏ —Ü–∏–∫–ª > 50–º—Å
        Serial.printf("‚ö†Ô∏è Long loop time: %lumS\n", loopTime);
    }

}

// ================== –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –§–£–ù–ö–¶–ò–ô ==================
void initializeSystem() {
    systemState = SystemState::INITIALIZING;
    Serial.println("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π...");
    
    // bool allOk = true;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    // –î–æ–±–∞–≤—å—Ç–µ —Ç–∞–π–º–∞—É—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    uint32_t initStart = millis();
    while (!ICMHandler::begin() && (( millis() - initStart) < 10000)) {
        Serial.println("‚ö†Ô∏è Retrying ICM initialization...");
        delay(1000);
    }
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SPI
    SPIManager::begin();
    Serial.println("SPI –º–µ–Ω–µ–¥–∂–µ—Ä: OK");
    
    // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IMU
    if (ICMHandler::begin()) {
        Serial.println("ICM-20948: OK");
    } else {
        Serial.println("ICM-20948: ERROR");
        systemState = SystemState::ERROR;
        return;
    }
    
    // 3. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SD –∫–∞—Ä—Ç—ã
    if (SDHandler::begin()) {
        Serial.println("SD –∫–∞—Ä—Ç–∞: OK");
    } else {
        Serial.println("SD –∫–∞—Ä—Ç–∞: WARNING");
    }
    
    // 4. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —ç–ª–µ—Ä–æ–Ω–æ–≤
    EleronController::begin();
    Serial.println("–°–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥—ã: OK");
    
    // 5. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–¥–∏–æ–º–æ–¥—É–ª—è
    if (radioReceiver.init() == EbyteStatus::SUCCESS) {
        Serial.println("–†–∞–¥–∏–æ–º–æ–¥—É–ª—å: OK");
    } else {
        Serial.println("–†–∞–¥–∏–æ–º–æ–¥—É–ª—å: ERROR");
        systemState = SystemState::ERROR;
        return;
    }
    
    systemState = SystemState::STANDBY;
    Serial.println("=== –°–ò–°–¢–ï–ú–ê –ì–û–¢–û–í–ê ===");
}

void handleSystemState() {
        //  static uint32_t lastStateChange = 0;
    
    switch (systemState) {
        case SystemState::STANDBY:
            // –ú–∏–≥–∞–Ω–∏–µ LED –≤ —Ä–µ–∂–∏–º–µ –æ–∂–∏–¥–∞–Ω–∏—è
            digitalWrite(LED_PIN, millis() % 1000 < 500);
            break;
            
        case SystemState::ACTIVE:
            // –ü–æ—Å—Ç–æ—è–Ω–Ω–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ
            digitalWrite(LED_PIN, HIGH);
            break;
            
        case SystemState::ERROR:
            // –ê–≤–∞—Ä–∏–π–Ω–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è
            digitalWrite(LED_PIN, millis() % 200 < 100);
            break;
            
        case SystemState::RECOVERY:
            systemRecovery();
            break;
            
        default:
            break;
    }
    
    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å–æ—Å—Ç–æ—è–Ω–∏—è
    if (systemState != previousState) {
        Serial.printf("–°–º–µ–Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è: %d -> %d\n", 
                     static_cast<int>(previousState), 
                     static_cast<int>(systemState));
        previousState = systemState;
              //  lastStateChange = millis();
    }
}

void processSensors() {
    static uint32_t lastIMURead = 0;
    
    if (millis() - lastIMURead >= ICM_READ_INTERVAL) {
        if (ICMHandler::readData()) {
            SensorData data = ICMHandler::getData();
            EleronController::update(data);
        }
        lastIMURead = millis();
    }
}

void handleRadioCommunication() {
    static uint32_t lastRadioProcess = 0;
    
    if (millis() - lastRadioProcess >= RADIO_PROCESS_INTERVAL) {
        radioReceiver.process(); // –ë—É–¥–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞–≤—Ç–æ–º–∞—Ç–∞
        //  radioReceiver.process();
        lastRadioProcess = millis();
    }
}

void controlOutputs() {
    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ EleronController
}

void logTelemetry() {
    static uint32_t lastSDWrite = 0;
    
    if (millis() - lastSDWrite >= SD_WRITE_INTERVAL) {
        SensorData data = ICMHandler::getData();
        SDHandler::writeData(data);
        lastSDWrite = millis();
    }
}

void updateSystemStatus() {
    static uint32_t lastStatusUpdate = 0;
    
    if (millis() - lastStatusUpdate >= STATUS_UPDATE_INTERVAL) {
        printStatusReport();
        lastStatusUpdate = millis();
    }
}

void handleEmergency() {
    Serial.println("!!! –ê–í–ê–†–ò–ô–ù–´–ô –†–ï–ñ–ò–ú !!!");
    EleronController::setNeutralPosition();
    
    static uint32_t emergencyStart = 0;
    if (emergencyStart == 0) {
        emergencyStart = millis();
    }
    
    if (millis() - emergencyStart > 10000) {
        systemState = SystemState::RECOVERY;
        emergencyStart = 0;
    }
}

void systemRecovery() {
    Serial.println("–ü–æ–ø—ã—Ç–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è...");
    
    SDHandler::end();
    delay(1000);
    
    if (ICMHandler::begin() && radioReceiver.init() == EbyteStatus::SUCCESS) {
        systemState = SystemState::STANDBY;
        Serial.println("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ!");
    } else {
        Serial.println("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å!");
        systemState = SystemState::ERROR;
    }
}

void printStatusReport() {
    Serial.println("\n=== –°–¢–ê–¢–£–° –°–ò–°–¢–ï–ú–´ ===");
    Serial.printf("–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: %lu —Å–µ–∫\n", millis() / 1000);
    Serial.printf("–°–æ—Å—Ç–æ—è–Ω–∏–µ: %d\n", static_cast<int>(systemState));
    Serial.printf("–û—à–∏–±–æ–∫: %lu\n", errorCount);
    Serial.printf("–ü–∞–º—è—Ç—å: %lu –±–∞–π—Ç\n", ESP.getFreeHeap());
    Serial.printf("–ß—Ç–µ–Ω–∏—è IMU: %lu\n", ICMHandler::getReadCount());
    Serial.printf("Radio State: %d\n", static_cast<int>(radioReceiver.getInternalState()));

    Serial.println("======================");
}

void checkSystemHealth() {
    static uint32_t lastHealthCheck = 0;
    
    if (millis() - lastHealthCheck >= ERROR_CHECK_INTERVAL) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–≥—Ä–µ–≤–∞
        float temp = temperatureRead();
        if (temp > 75.0) {
            Serial.println("–ü–µ—Ä–µ–≥—Ä–µ–≤ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞!");
            systemState = SystemState::ERROR;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏
        if (ESP.getFreeHeap() < 10000) {
            Serial.println("–ú–∞–ª–æ —Å–≤–æ–±–æ–¥–Ω–æ–π –ø–∞–º—è—Ç–∏!");
        }
        
        lastHealthCheck = millis();
    }
}





//====================================================================
//	3. –§–∞–π–ª E49_Controller.cpp
//====================================================================
//  3. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π E49_Controller.cpp
//
#include "E49_Controller.h"
#include <SD.h>
#include <SPI.h>

// –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ä–∞—Å—á–µ—Ç–∞ CRC8
static const uint8_t crc8_table[256] = {
    0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
    0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
    0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
    0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
    0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
    0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
    0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
    0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42, 0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
    0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
    0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
    0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
    0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
    0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
    0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
    0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
    0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
};


E49_Controller::E49_Controller(bool isSender, HardwareSerial* serial) :
    _isSender(isSender),
    _debugEnabled(false),
    _ledState(false),
    _lastLedToggle(0),
    _internalState(InternalState::IDLE),
    _stateStartTime(0),
    _currentRetry(0),
    _lastResetTime(0),
    _lastSaveTime(0)
{
    memset(&_stats, 0, sizeof(_stats));
    memset(&_currentTxPacket, 0, sizeof(_currentTxPacket));
    memset(&_currentRxPacket, 0, sizeof(_currentRxPacket));
    memset(&_currentAckPacket, 0, sizeof(_currentAckPacket));
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è serial –ø–æ—Ä—Ç–∞
    serial->begin(E49_BAUDRATE, SERIAL_8N1, E49_PIN_RX, E49_PIN_TX);
    //  _transceiver = new EBYTE(serial, E49_PIN_M0, E49_PIN_M1, E49_PIN_AUX);
    _transceiver = new EBYTE(serial, E49_PIN_M0, E49_PIN_M1, E49_PIN_AUX);
    _lastActivityTime = millis();
    _lastReconnectAttempt = millis();
}

E49_Controller::~E49_Controller() {
    if (_transceiver != nullptr) {
        delete _transceiver;
        _transceiver = nullptr;
    }
}

// E49_Controller.cpp - –¥–æ–±–∞–≤—å—Ç–µ –ø–æ—Å–ª–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞:
EbyteStatus E49_Controller::reinitialize() {
    if (_debugEnabled) {
        Serial.println("Reinitializing E49 module...");
    }
    
    // –°–±—Ä–æ—Å –º–æ–¥—É–ª—è
    resetModule();
    delay(100);
    
    // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    if (!_transceiver->init()) {
        return EbyteStatus::ERROR_INIT;
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    _transceiver->SetParityBit(PB_8N1);
    _transceiver->SetAddressH(E49_ADDRESS_H);
    _transceiver->SetAddressL(E49_ADDRESS_L);
    _transceiver->SetChannel(E49_CHANNEL);
    _transceiver->SetAirDataRate(ADR_19200);
    _transceiver->SetUARTBaudRate(UDR_9600);
    
    _transceiver->SaveParameters(PERMANENT);
    _lastSaveTime = millis();
    
    return EbyteStatus::SUCCESS;
}


void E49_Controller::changeState(InternalState newState) {
    if (_debugEnabled) {
        const char* stateNames[] = {
            "IDLE", "WAITING_FOR_AUX", "SENDING_DATA", "WAITING_FOR_ACK",
            "RECEIVING_DATA", "PROCESSING_DATA", "SENDING_ACK", "RESETTING", "ERROR"
        };
        
        Serial.printf("üìª [%lu] Radio FSM: %s -> %s (Retry: %d)\n", 
                    millis(),
                    stateNames[static_cast<int>(_internalState)],
                    stateNames[static_cast<int>(newState)],
                    _currentRetry);
    }
    _internalState = newState;
    _stateStartTime = millis();
}


EbyteStatus E49_Controller::init() {
    //    pinMode(LED_PIN, OUTPUT);
    digitalWrite(LED_PIN, LOW);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª—è
    if (!_transceiver->init()) {
        if (_debugEnabled) Serial.println("E49 module initialization failed");
        return EbyteStatus::ERROR_INIT;
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–æ–¥—É–ª—è
    _transceiver->SetParityBit(PB_8N1);
    _transceiver->SetAddressH(E49_ADDRESS_H);
    _transceiver->SetAddressL(E49_ADDRESS_L);
    _transceiver->SetChannel(E49_CHANNEL);
    _transceiver->SetAirDataRate(ADR_19200);
    _transceiver->SetUARTBaudRate(UDR_9600);

    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (–Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ–µ)
    _transceiver->SaveParameters(PERMANENT);
    _lastSaveTime = millis();
    
    if (_debugEnabled) {
        Serial.println("E49 module initialization started");
    }
    changeState(InternalState::IDLE); // –£–±–∏—Ä–∞–µ–º INITIALIZING
    return EbyteStatus::SUCCESS;

}

EbyteStatus E49_Controller::waitForAux(uint32_t timeout) {
    uint32_t startTime = millis();
    
    while (millis() - startTime < timeout) {
        if (digitalRead(E49_PIN_AUX) == HIGH) {
            return EbyteStatus::SUCCESS;
        }
        
        // –ù–µ–±–ª–æ–∫–∏—Ä—É—é—â–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        delay(1);
        yield();
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ LED –∏–Ω–¥–∏–∫–∞—Ü–∏–∏
        updateLED();
    }
    
    _stats.aux_timeouts++;
    return EbyteStatus::ERROR_AUX_TIMEOUT;
}

uint8_t E49_Controller::calculateCRC8(const uint8_t* data, size_t length) const {
    uint8_t crc = 0;
    
    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç CRC8 —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ç–∞–±–ª–∏—Ü—ã
    for (size_t i = 0; i < length; i++) {
        crc = crc8_table[crc ^ data[i]];
    }
    
    return crc;
}

void E49_Controller::process() {
    updateLED();
    

    switch (_internalState) {
        case InternalState::IDLE:
            if (!_isSender) {
                // –ü—Ä–∏–µ–º–Ω–∏–∫ –æ–∂–∏–¥–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ
                if (_transceiver->available()) {
                    changeState(InternalState::RECEIVING_DATA);
                }
            }
            break;
            
        case InternalState::WAITING_FOR_AUX:
            if (digitalRead(E49_PIN_AUX) == HIGH) {
                changeState(InternalState::SENDING_DATA);
            } else if (millis() - _stateStartTime > AUX_TIMEOUT_MS) {
                _stats.aux_timeouts++;
                if (++_currentRetry < MAX_RETRIES) {
                    changeState(InternalState::WAITING_FOR_AUX);
                } else {
                    changeState(InternalState::ERROR);
                }
            }
            break;
            
        case InternalState::SENDING_DATA:
            if (_transceiver->SendStruct(&_currentTxPacket, sizeof(_currentTxPacket))) {
                _stats.tx_packets++;
                _lastActivityTime = millis();
                
                BitMask mask(_currentTxPacket.comSetAll);
                if (mask.getBit(0)) {
                    changeState(InternalState::WAITING_FOR_ACK);
                } else {
                    changeState(InternalState::IDLE);
                }
            } else {
                _stats.tx_errors++;
                if (++_currentRetry < MAX_RETRIES) {
                    changeState(InternalState::WAITING_FOR_AUX);
                } else {
                    changeState(InternalState::ERROR);
                }
            }
            break;
            
        case InternalState::WAITING_FOR_ACK:
            {
                AckPacket_t ack;
                EbyteStatus status = receiveAck(ack);
                
                if (status == EbyteStatus::SUCCESS) {
                    if (ack.packet_id == _currentTxPacket.packet_id) {
                        changeState(InternalState::IDLE);
                    }
                } else if (status != EbyteStatus::ERROR_NO_NEW_DATA) {
                    if (++_currentRetry < MAX_RETRIES) {
                        changeState(InternalState::WAITING_FOR_AUX);
                    } else {
                        changeState(InternalState::ERROR);
                    }
                }
                
                if (millis() - _stateStartTime > ACK_TIMEOUT_MS) {
                    _stats.receive_timeouts++;
                    if (++_currentRetry < MAX_RETRIES) {
                        changeState(InternalState::WAITING_FOR_AUX);
                    } else {
                        changeState(InternalState::ERROR);
                    }
                }
            }
            break;
            
        case InternalState::RECEIVING_DATA:
            if (_transceiver->GetStruct(&_currentRxPacket, sizeof(_currentRxPacket))) {
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–∞–º–±—É–ª—ã
                if (_currentRxPacket.preamble[0] != PACKET_PREAMBLE_1 || 
                    _currentRxPacket.preamble[1] != PACKET_PREAMBLE_2) {
                    _stats.preamble_errors++;
                    changeState(InternalState::IDLE);
                    break;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ CRC
                uint8_t crc = _currentRxPacket.crc8;
                _currentRxPacket.crc8 = 0;
                uint8_t calculated_crc = calculateCRC8((uint8_t*)&_currentRxPacket, sizeof(_currentRxPacket) -1);
                
                if (crc != calculated_crc) {
                    _stats.crc_errors++;
                    changeState(InternalState::IDLE);
                    break;
                }
                
                _stats.rx_packets++;
                _lastActivityTime = millis();
                
                BitMask mask(_currentRxPacket.comSetAll);
                if (mask.getBit(0)) {
                    changeState(InternalState::SENDING_ACK);
                } else {
                    changeState(InternalState::IDLE);
                }
                
                if (_debugEnabled) {
                    Serial.print("Received packet ID: ");
                    Serial.println(_currentRxPacket.packet_id);
                }
            } else {
                changeState(InternalState::IDLE);
            }
            break;
            
        case InternalState::SENDING_ACK:
            {
                EbyteStatus status = sendAck(_currentRxPacket.packet_id, 1);
                if (status == EbyteStatus::SUCCESS) {
                    changeState(InternalState::IDLE);
                } else {
                    if (++_currentRetry < MAX_RETRIES) {
                        changeState(InternalState::SENDING_ACK);
                    } else {
                        changeState(InternalState::ERROR);
                    }
                }
            }
            break;
            
        case InternalState::ERROR:
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
            handleConnectionRecovery();
            break;
            
        default:
            changeState(InternalState::IDLE);
            break;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    handleConnectionRecovery();
}

EbyteStatus E49_Controller::sendAck(uint16_t packet_id, uint8_t status) {
    AckPacket_t ack;
    ack.preamble[0] = ACK_PREAMBLE_1;
    ack.preamble[1] = ACK_PREAMBLE_2;
    ack.packet_id = packet_id;
    ack.timestamp = millis();
    ack.status = status;
    ack.crc8 = calculateCRC8((uint8_t*)&ack, sizeof(ack) - 1);
    
    EbyteStatus auxStatus = waitForAux();
    if (auxStatus != EbyteStatus::SUCCESS) {
        return auxStatus;
    }
    
    if (_transceiver->SendStruct(&ack, sizeof(ack))) {
        return EbyteStatus::SUCCESS;
    }
    
    return EbyteStatus::ERROR_SEND;
}

EbyteStatus E49_Controller::receiveAck(AckPacket_t& ack) {
    if (!_transceiver->available()) {
        return EbyteStatus::ERROR_NO_NEW_DATA;
    }
    
    if (_transceiver->GetStruct(&ack, sizeof(ack))) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–µ–∞–º–±—É–ª—ã
        if (ack.preamble[0] != ACK_PREAMBLE_1 || ack.preamble[1] != ACK_PREAMBLE_2) {
            _stats.preamble_errors++;
            return EbyteStatus::ERROR_INVALID_DATA;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ CRC
        uint8_t crc = ack.crc8;
        ack.crc8 = 0;
        uint8_t calculated_crc = calculateCRC8((uint8_t*)&ack, sizeof(ack) -1);
        
        if (crc != calculated_crc) {
            _stats.crc_errors++;
            return EbyteStatus::ERROR_CRC;
        }
        
        return EbyteStatus::SUCCESS;
    }
    
    return EbyteStatus::ERROR_NO_NEW_DATA;
}

void E49_Controller::handleConnectionRecovery() {
    if (millis() - _lastActivityTime > CONNECTION_TIMEOUT_MS) {
        _stats.connection_lost_events++;
        
        if (millis() - _lastReconnectAttempt > RECONNECT_INTERVAL_MS) {
            _lastReconnectAttempt = millis();
            
            if (attemptRecovery()) {
                _stats.reconnects++;
                _lastActivityTime = millis();
                changeState(InternalState::IDLE);
                
                if (_debugEnabled) {
                    Serial.println("Connection recovered successfully");
                }
            } else if (_debugEnabled) {
                Serial.println("Connection recovery failed");
            }
        }
    }
}

bool E49_Controller::attemptRecovery() {
    if (_debugEnabled) {
        Serial.println("Attempting module recovery...");
    }
    
    // –°–±—Ä–æ—Å –º–æ–¥—É–ª—è
    resetModule();
    delay(200);
    
    // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    if (reinitialize() != EbyteStatus::SUCCESS) {
        return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –º–æ–¥—É–ª—è
    if (waitForAux(500) != EbyteStatus::SUCCESS) {
        return false;
    }
    
    return testCommunication();
}

bool E49_Controller::testCommunication() {
    if (_isSender) {
        DataComSet_t testPacket = createTestPacket();
        testPacket.comSetAll = COM_SETALL_MASK;
        
        EbyteStatus status = startSendingData(testPacket);
        if (status != EbyteStatus::SUCCESS) return false;
        
        // –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏
        uint32_t startTime = millis();
        while (_internalState != InternalState::IDLE && 
               (millis() - startTime) < 2000) {
            process();
            delay(10);
        }
        
        return _internalState == InternalState::IDLE;
    } else {
        // –î–ª—è –ø—Ä–∏–µ–º–Ω–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å AUX
        return (waitForAux(100) == EbyteStatus::SUCCESS);
    }
}

void E49_Controller::resetModule() {
    if (_debugEnabled) Serial.println("Resetting module...");
    
    _transceiver->Reset();
    delay(100);
    _stats.resets++;
    _lastActivityTime = millis();
}

void E49_Controller::updateLED() {
    if (millis() - _lastLedToggle > LED_BLINK_INTERVAL_MS) {
        _ledState = !_ledState;
        digitalWrite(LED_PIN, _ledState ? HIGH : LOW);
        _lastLedToggle = millis();
    }
}

DataComSet_t E49_Controller::createTestPacket() const {
    DataComSet_t packet;
    packet.preamble[0] = PACKET_PREAMBLE_1;
    packet.preamble[1] = PACKET_PREAMBLE_2;
    packet.packet_id = 0xFFFF;
    packet.comUp = 127;
    packet.comLeft = 127;
    packet.comThrottle = 1500;
    packet.comParashut = 0;
    packet.timestamp = millis();
    packet.comSetAll = 0;
    packet.crc8 = calculateCRC8((uint8_t*)&packet, sizeof(packet) - 1);
    
    return packet;
}

EbyteStatus E49_Controller::startSendingData(const DataComSet_t& data) {
    if (!_isSender) return EbyteStatus::ERROR_BUSY;
    if (_internalState != InternalState::IDLE) return EbyteStatus::ERROR_BUSY;
    
    _currentTxPacket = data;
    _currentTxPacket.preamble[0] = PACKET_PREAMBLE_1;
    _currentTxPacket.preamble[1] = PACKET_PREAMBLE_2;
    _currentTxPacket.crc8 = calculateCRC8((uint8_t*)&_currentTxPacket, sizeof(_currentTxPacket) - 1);
    
    _currentRetry = 0;
    changeState(InternalState::WAITING_FOR_AUX);
    
    return EbyteStatus::SUCCESS;
}

void E49_Controller::printStatus(EbyteStatus status) const {
    switch(status) {
        case EbyteStatus::SUCCESS: Serial.println("Success"); break;
        case EbyteStatus::ERROR_AUX_TIMEOUT: Serial.println("AUX timeout"); break;
        case EbyteStatus::ERROR_SEND: Serial.println("Send error"); break;
        case EbyteStatus::ERROR_RECEIVE: Serial.println("Receive error"); break;
        case EbyteStatus::ERROR_CRC: Serial.println("CRC error"); break;
        case EbyteStatus::ERROR_INVALID_DATA: Serial.println("Invalid data"); break;
        case EbyteStatus::ERROR_NO_NEW_DATA: Serial.println("No new data"); break;
        case EbyteStatus::ERROR_CONNECTION_LOST: Serial.println("Connection lost"); break;
        case EbyteStatus::ERROR_NOT_READY: Serial.println("Not ready"); break;
        case EbyteStatus::ERROR_BUSY: Serial.println("Busy"); break;
        default: Serial.println("Unknown error"); break;
    }
}

void E49_Controller::printStats() const {
    Serial.println("=== E49 Module Statistics ===");
    Serial.print("TX packets: "); Serial.println(_stats.tx_packets);
    Serial.print("RX packets: "); Serial.println(_stats.rx_packets);
    Serial.print("CRC errors: "); Serial.println(_stats.crc_errors);
    Serial.print("TX errors: "); Serial.println(_stats.tx_errors);
    Serial.print("RX errors: "); Serial.println(_stats.rx_errors);
    Serial.print("Resets: "); Serial.println(_stats.resets);
    Serial.print("Reconnects: "); Serial.println(_stats.reconnects);
    Serial.print("AUX timeouts: "); Serial.println(_stats.aux_timeouts);
    Serial.print("Connection lost events: "); Serial.println(_stats.connection_lost_events);
    Serial.println("============================");
}

void E49_Controller::enableDebug(bool enable) {
    _debugEnabled = enable;
}

void E49_Controller::forceRecovery() {
    if (_debugEnabled) {
        Serial.println("Forced recovery initiated");
    }
    _lastReconnectAttempt = 0;
    _lastActivityTime = millis() - CONNECTION_TIMEOUT_MS - 1;
    handleConnectionRecovery();
}

bool E49_Controller::isConnectionLost() const {
    return (millis() - _lastActivityTime) > CONNECTION_TIMEOUT_MS;
}

//====================================================================





//===============================================
//  4. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π Eleron_Controller.cpp
//=================================================
//
//  üìã –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è Eleron_Controller.cpp
//
#include "Eleron_Controller.h"
#include <driver/ledc.h>
#include <math.h>

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤ (—É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ E49_Config.h)
extern const int servoPins[5];
extern const ledc_channel_t channels[5];


// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
// int angles[5] = {90,90,90,90,0};

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
uint32_t EleronController::last_update_time = 0;
int EleronController::current_angles[5] = {90, 90, 90, 90, 0};
bool EleronController::test_running = false;
uint32_t EleronController::test_start_time = 0;
uint8_t EleronController::test_phase = 0;
// Eleron_Controller.cpp    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞:
//  extern float servoAngles[5]; // –û–±—ä—è–≤–ª—è–µ–º –≤–Ω–µ—à–Ω—é—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é
extern int servoAngles[5]; // –û–±—ä—è–≤–ª—è–µ–º –≤–Ω–µ—à–Ω—é—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é


void EleronController::begin() {
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–∞–π–º–µ—Ä–∞ LEDC
    ledc_timer_config_t timer_conf = {};
    timer_conf.speed_mode = LEDC_LOW_SPEED_MODE;
    timer_conf.duty_resolution = LEDC_TIMER_12_BIT;
    timer_conf.timer_num = LEDC_TIMER_0;
    timer_conf.freq_hz = 50;
    timer_conf.clk_cfg = LEDC_AUTO_CLK;
    ledc_timer_config(&timer_conf);
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞–Ω–∞–ª–æ–≤
    for (int i = 0; i < 5; i++) {
        ledc_channel_config_t channel_conf = {};
        channel_conf.gpio_num = servoPins[i];
        channel_conf.speed_mode = LEDC_LOW_SPEED_MODE;
        //channel_conf.channel = channels[i];
        channel_conf.channel = servoChannels[i];        

        channel_conf.intr_type = LEDC_INTR_DISABLE;
        channel_conf.timer_sel = LEDC_TIMER_0;
        channel_conf.duty = 0;
        channel_conf.hpoint = 0;
        ledc_channel_config(&channel_conf);
        
        setServoAngle(i, 90); // –ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
    }
    
    last_update_time = millis();
    Serial.println("‚úÖ EleronController initialized");
}

void EleronController::setNeutralPosition() {
    for (int i = 0; i < 5; i++) {
        setServoAngle(i, 90);
    }
    Serial.println("‚úÖ Servos set to neutral position");
}

void EleronController::update(const SensorData& data) {
    uint32_t current_time = millis();
    
    if ((current_time - last_update_time) < UPDATE_INTERVAL && 
        current_time >= last_update_time) {
        return;
    }
    
    if (test_running) {
        runTestSequence();
    } else {
        processIMUData(data);
    }
    
    last_update_time = current_time;
}

void EleronController::processIMUData(const SensorData& data) {
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —É–≥–ª—ã –∏–∑ IMU –≤ –¥–∏–∞–ø–∞–∑–æ–Ω —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
    int pitch_angle = constrain(map(data.euler[1], -90, 90, 0, 180), 0, 180);
    int roll_angle = constrain(map(data.euler[0], -90, 90, 0, 180), 0, 180);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
    ::servoAngles[0] = roll_angle;
    ::servoAngles[1] = pitch_angle;
    ::servoAngles[2] = 90;
    ::servoAngles[3] = 180 - roll_angle;
    ::servoAngles[4] = 90;
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —É–≥–ª—ã —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
    for (int i = 0; i < 5; i++) {
        setServoAngle(i, ::servoAngles[i]);
    }
}

void EleronController::setServoAngle(uint8_t channel, int angle) {
    if (channel >= 5) return;
    
    angle = constrain(angle, 0, 180);
    current_angles[channel] = angle;
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —É–≥–ª–∞ –≤ –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥—ã (500-2400Œºs)
    int pulse_width = map(angle, 0, 180, 500, 2400);
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ duty —Ü–∏–∫–ª (12-bit resolution, 50Hz)
    uint32_t duty = (pulse_width * 4096UL) / 20000UL;
            //  duty = constrain(duty, 0, 4095);
    if (duty > 4095) duty = 4095;

            //  ledcWrite(channels[channel], duty);
    ledcWrite(servoChannels[channel], duty);

}

void EleronController::startTestSequence() {
    test_running = true;
    test_start_time = millis();
    Serial.println("üöÄ Starting servo test sequence for all 5 servos...");
}

void EleronController::stopTestSequence() {
    test_running = false;
    Serial.println("üõë Servo test sequence stopped");
    setNeutralPosition();
}

void EleronController::runTestSequence() {
    if (!test_running) return;
    
    uint32_t current_time = millis();
    uint32_t elapsed = current_time - test_start_time;
    uint32_t phase_time = elapsed % 8000;
    
    for (int i = 0; i < 5; i++) {
        int angle = 90;
        
        switch (i) {
            case 0:
                angle = (phase_time < 4000) ? 
                    map(phase_time, 0, 4000, 0, 180) :
                    map(phase_time, 4000, 8000, 180, 0);
                break;
                
            case 1:
                angle = 90 + 60 * sin(2 * M_PI * phase_time / 2000.0);
                break;
                
            case 2:
                if (phase_time < 2000) angle = 45;
                else if (phase_time < 4000) angle = 90;
                else if (phase_time < 6000) angle = 135;
                else angle = 90;
                break;
                
            case 3:
                angle = map(phase_time, 0, 8000, 0, 180);
                break;
                
            case 4:
                angle = 90 + 30 * sin(2 * M_PI * phase_time / 3000.0) + 
                        20 * cos(2 * M_PI * phase_time / 5000.0);
                break;
        }
        
        angle = constrain(angle, 0, 180);
        servoTargetAngles[i] = angle;
        setServoAngle(i, angle);
    }
    
    if (elapsed % 1000 < 20) {
        Serial.printf("üîß Test: %lu ms | Angles: %d, %d, %d, %d, %d\n",
            elapsed, current_angles[0], current_angles[1], current_angles[2],
            current_angles[3], current_angles[4]);
    }
    
    if (elapsed > 60000) {
        stopTestSequence();
    }
}
//=============================================================================================================
// ================== –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –ì–õ–û–ë–ê–õ–¨–ù–´–• –ü–ï–†–ï–ú–ï–ù–ù–´–• ==================
//  int angles[5] = { 90, 90, 90, 90, 0 };
//  int targetAngles[5] = { 90, 90, 90, 90, 0 };


    //======================================
    //  3. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π ICM_Handler.cpp
    //======================================
    //  4. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π ICM_Handler.cpp
    //
    //  6. ICM_Handler.cpp - –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –±—É—Ñ–µ—Ä–æ–º
    //

#include "ICM_Handler.h"

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
uint32_t ICMHandler::last_read_time = 0;
SensorData ICMHandler::current_data = {
    .timestamp = 0,
    .accel = {0, 0, 0},
    .gyro = {0, 0, 0},
    .mag = {0, 0, 0},
    .euler = {0, 0, 0},
    .quat = {0, 0, 0, 0},
    .status = 0
};
uint32_t ICMHandler::read_count = 0;
uint32_t ICMHandler::error_count = 0;

// –ë—É—Ñ–µ—Ä–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
SensorData ICMHandler::data_buffer[ICMHandler::BUFFER_SIZE];
size_t ICMHandler::buffer_index = 0;
bool ICMHandler::buffer_overflow = false;

    /*  
// ICM_Handler.cpp
bool ICMHandler::begin() {
    if (!SPIManager::acquireForICM(10)) {
        return false;
    }

    // –ë—ã—Å—Ç—Ä–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è
    SPIClass& spi = SPIManager::getSPI();
    spi.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
    
    digitalWrite(SPI_ICM_CS, LOW);
    spi.transfer(0x80 | 0x00);
    uint8_t id = spi.transfer(0);
    digitalWrite(SPI_ICM_CS, HIGH);
    
    spi.endTransaction();
    SPIManager::release();
    
    bool success = (id == 0xEA);
    if (success) {
        Serial.println("ICM initialized");
    }
    
    return success;
}
*/

    
bool ICMHandler::begin() {
    if (!SPIManager::acquireForICM(10)) {
        error_count++;
        return false;
    }

    bool success = false;
    SPIClass& spi = SPIManager::getSPI();
    
    spi.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
    try {
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ICM
        digitalWrite(SPI_ICM_CS, LOW);
        spi.transfer(0x80 | 0x00); // WHO_AM_I
        uint8_t id = spi.transfer(0);
        digitalWrite(SPI_ICM_CS, HIGH);
        
        success = (id == 0xEA);
        if (success) {
            Serial.println("‚úÖ ICM-20948 initialized successfully");
        } else {
            Serial.printf("‚ùå ICM-20948 init failed. ID: 0x%02X\n", id);
        }
    } catch (...) {
        success = false;
        Serial.println("‚ùå Exception during ICM initialization");
    }
    

    spi.endTransaction();
    SPIManager::release();
    
    if (!success) error_count++;
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±—É—Ñ–µ—Ä–∞
    clearBuffer();
    
    return success;
}

bool ICMHandler::readData() {
    uint32_t current_time = millis();
    
    // –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è millis()
    if (current_time - last_read_time < READ_INTERVAL) {
        return false;
    }

    //if ((uint32_t)(current_time - last_read_time) < READ_INTERVAL) {
    //    return false;
    //}

    if (!SPIManager::acquireForICM(5)) {
        error_count++;
        Serial.println("‚ö†Ô∏è Failed to acquire SPI for ICM");
        return false;
    }

    bool read_success = true;
    SPIClass& spi = SPIManager::getSPI();
    
    try {
        spi.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0));
        
        // –ß—Ç–µ–Ω–∏–µ –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä–∞
        digitalWrite(SPI_ICM_CS, LOW);
        spi.transfer(0x80 | 0x2D); // ACCEL_XOUT_H
        current_data.accel[0] = (spi.transfer(0) << 8) | spi.transfer(0);
        current_data.accel[1] = (spi.transfer(0) << 8) | spi.transfer(0);
        current_data.accel[2] = (spi.transfer(0) << 8) | spi.transfer(0);
        digitalWrite(SPI_ICM_CS, HIGH);
        
       // –ß—Ç–µ–Ω–∏–µ –≥–∏—Ä–æ—Å–∫–æ–ø–∞ (–¥–æ–±–∞–≤—å—Ç–µ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ)
        // –ß—Ç–µ–Ω–∏–µ –≥–∏—Ä–æ—Å–∫–æ–ø–∞
        digitalWrite(SPI_ICM_CS, LOW);
        spi.transfer(0x80 | 0x33); // GYRO_XOUT_H
        current_data.gyro[0] = ((int16_t)(spi.transfer(0) << 8) | spi.transfer(0)) * 250.0 / 32768.0;
        current_data.gyro[1] = ((int16_t)(spi.transfer(0) << 8) | spi.transfer(0)) * 250.0 / 32768.0;
        current_data.gyro[2] = ((int16_t)(spi.transfer(0) << 8) | spi.transfer(0)) * 250.0 / 32768.0;
        digitalWrite(SPI_ICM_CS, HIGH);

        // –ß—Ç–µ–Ω–∏–µ –º–∞–≥–Ω–∏—Ç–æ–º–µ—Ç—Ä–∞ (—Ç—Ä–µ–±—É–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏)
        digitalWrite(SPI_ICM_CS, LOW);
        spi.transfer(0x80 | 0x11); // MAG_XOUT_L
        int16_t mag_x = (spi.transfer(0) << 8) | spi.transfer(0);
        int16_t mag_y = (spi.transfer(0) << 8) | spi.transfer(0);
        int16_t mag_z = (spi.transfer(0) << 8) | spi.transfer(0);
        digitalWrite(SPI_ICM_CS, HIGH);

        current_data.mag[0] = mag_x * 0.15; // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ ¬µT
        current_data.mag[1] = mag_y * 0.15;
        current_data.mag[2] = mag_z * 0.15;
         // –ß—Ç–µ–Ω–∏–µ –º–∞–≥–Ω–∏—Ç–æ–º–µ—Ç—Ä–∞ (–¥–æ–±–∞–≤—å—Ç–µ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ)
        
        spi.endTransaction();
        
    } catch (...) {
        read_success = false;
        Serial.println("‚ùå Exception during ICM data reading");
    }
    
    SPIManager::release();

    if (read_success) {
        current_data.timestamp = current_time;
        last_read_time = current_time;
        read_count++;
        
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ –±—É—Ñ–µ—Ä
        addToBuffer(current_data);
        
        // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –æ—Ç—á–µ—Ç –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –±—É—Ñ–µ—Ä–∞
        if (read_count % 50 == 0) {
            Serial.printf("üìä ICM Buffer: %d/%d (%.1f%%)", 
                         buffer_index, BUFFER_SIZE, getBufferUsage());
            if (buffer_overflow) Serial.print(" [OVERFLOW]");
            Serial.println();
        }
        if (read_success && read_count % 20 == 0) {
                Serial.printf("üìä [%lu] IMU: A(%.2f,%.2f,%.2f) G(%.2f,%.2f,%.2f) M(%.2f,%.2f,%.2f)\n", millis(),
                 current_data.accel[0], current_data.accel[1], current_data.accel[2],
                 current_data.gyro[0], current_data.gyro[1], current_data.gyro[2],
                 current_data.mag[0], current_data.mag[1], current_data.mag[2]);
        }
    } else {
        error_count++;
    }
    
    return read_success;
}

bool ICMHandler::addToBuffer(const SensorData& data) {
    if (buffer_index < BUFFER_SIZE) {
        data_buffer[buffer_index++] = data;
        return true;
    } else {
        buffer_overflow = true;
        Serial.println("‚ö†Ô∏è ICM buffer overflow! Data lost.");
        return false;
    }
}

const SensorData& ICMHandler::getData() {
    return current_data;
}

bool ICMHandler::isDataFresh() {
    uint32_t current_time = millis();
    return (uint32_t)(current_time - last_read_time) < (READ_INTERVAL + 5);
}

uint32_t ICMHandler::getReadCount() {
    return read_count;
}

uint32_t ICMHandler::getErrorCount() {
    return error_count;
}


//=================================================================================
    /*
    //  7. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å SDHandler - –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±—É—Ñ–µ—Ä–∞
    //  cpp

// –í –æ—Å–Ω–æ–≤–Ω–æ–º –∫–æ–¥–µ –∏–ª–∏ –≤ SDHandler
void processICMData() {
    if (ICMHandler::getBufferSize() > 0) {
        const SensorData* buffer = ICMHandler::getBuffer();
        size_t buffer_size = ICMHandler::getBufferSize();
        
        // –ü–∞–∫–µ—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å –≤ SD
        for (size_t i = 0; i < buffer_size; i++) {
            SDHandler::writeData(buffer[i]);
        }
        
        // –û—á–∏—Å—Ç–∫–∞ –±—É—Ñ–µ—Ä–∞ –ø–æ—Å–ª–µ –∑–∞–ø–∏—Å–∏
        ICMHandler::clearBuffer();
        
        Serial.printf("üíæ Written %d samples from ICM buffer to SD\n", buffer_size);
    }
}

// –ò–ª–∏ –≤ loop()
void loop() {
    // –ß—Ç–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å ICM
    ICMHandler::readData();
    
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –∑–∞–ø–∏—Å—å –±—É—Ñ–µ—Ä–∞ –Ω–∞ SD (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã)
    static uint32_t last_buffer_flush = 0;
    if (millis() - last_buffer_flush > 2000) {
        processICMData();
        last_buffer_flush = millis();
    }
}
    */
//========================================================================================

//=============================================================================
//==============    ( motor_controller.cpp )  ===================================
//=============================================================================
//==============================================================================
//==============================================================================
//==============================================================================
//	üìÑ motor_controller.cpp (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π)
//==============================================================================
//üìÑ   motor_controller.cpp (–µ–¥–∏–Ω—ã–π —Ñ–∞–π–ª)
//=============================================================================
//  üìÑ motor_controller.cpp (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
//=============================================================================

#include <Arduino.h>
#include "motor_controller.h"
#include "Config.h"
MotorController motor_controller;

MotorController::MotorController() 
    : current_speed_a(0), current_speed_b(0),
      is_test_running(false), test_start_time(0), last_report_time(0) {
}

MotorController::~MotorController() {
    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
    safe_delete(generator_a);
    safe_delete(generator_b);
    safe_delete(comparator_a);
    safe_delete(comparator_b);
    safe_delete(oper_a);
    safe_delete(oper_b);
    safe_delete(timer_a);
    safe_delete(timer_b);
}

void MotorController::safe_delete(mcpwm_timer_handle_t& handle) {
    if (handle) {
        esp_err_t err = mcpwm_del_timer(handle);
        if (err == ESP_OK) handle = nullptr;
    }
}

void MotorController::safe_delete(mcpwm_oper_handle_t& handle) {
    if (handle) {
        esp_err_t err = mcpwm_del_operator(handle);
        if (err == ESP_OK) handle = nullptr;
    }
}

void MotorController::safe_delete(mcpwm_cmpr_handle_t& handle) {
    if (handle) {
        esp_err_t err = mcpwm_del_comparator(handle);
        if (err == ESP_OK) handle = nullptr;
    }
}

void MotorController::safe_delete(mcpwm_gen_handle_t& handle) {
    if (handle) {
        esp_err_t err = mcpwm_del_generator(handle);
        if (err == ESP_OK) handle = nullptr;
    }
}

bool MotorController::init_esc() {
    Serial.println("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MCPWM Prelude API");
    
    init_mcpwm_components();
    setup_generator_actions();
    
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
    set_motors_speed(0);
    
    Serial.println("MotorController –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");
    Serial.printf("ESC –ø–∏–Ω—ã: GPIO%d (–ú–æ—Ç–æ—Ä A), GPIO%d (–ú–æ—Ç–æ—Ä B)\n", ESC_A_PIN, ESC_B_PIN);
    return true;
}

void MotorController::init_mcpwm_components() {
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–∞–π–º–µ—Ä–æ–≤ —Å –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
    mcpwm_timer_config_t timer_config = {};
    timer_config.group_id = 0;
    timer_config.clk_src = MCPWM_TIMER_CLK_SRC_DEFAULT;
    timer_config.resolution_hz = 10000000; // 10MHz
    timer_config.count_mode = MCPWM_TIMER_COUNT_MODE_UP;
    timer_config.period_ticks = 200000; // 50Hz: 10MHz/50Hz = 200000 ticks
    timer_config.intr_priority = 0;
    timer_config.flags.update_period_on_empty = true;
    timer_config.flags.update_period_on_sync = true;
    
    // –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–π–º–µ—Ä–æ–≤
    ESP_ERROR_CHECK(mcpwm_new_timer(&timer_config, &timer_a));
    ESP_ERROR_CHECK(mcpwm_new_timer(&timer_config, &timer_b));
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ —Å –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
    mcpwm_operator_config_t operator_config = {};
    operator_config.group_id = 0;
    operator_config.intr_priority = 0;
    operator_config.flags.update_gen_action_on_tez = true;
    operator_config.flags.update_gen_action_on_tep = false;
    operator_config.flags.update_gen_action_on_sync = false;
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
    ESP_ERROR_CHECK(mcpwm_new_operator(&operator_config, &oper_a));
    ESP_ERROR_CHECK(mcpwm_new_operator(&operator_config, &oper_b));
    
    // –ü—Ä–∏–≤—è–∑–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∫ —Ç–∞–π–º–µ—Ä–∞–º
    ESP_ERROR_CHECK(mcpwm_operator_connect_timer(oper_a, timer_a));
    ESP_ERROR_CHECK(mcpwm_operator_connect_timer(oper_b, timer_b));
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–æ–≤ —Å –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–µ–π
    mcpwm_comparator_config_t comparator_config = {};
    comparator_config.intr_priority = 0;
    comparator_config.flags.update_cmp_on_tez = true;
    comparator_config.flags.update_cmp_on_tep = false;
    comparator_config.flags.update_cmp_on_sync = false;
    
    // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–æ–≤
    ESP_ERROR_CHECK(mcpwm_new_comparator(oper_a, &comparator_config, &comparator_a));
    ESP_ERROR_CHECK(mcpwm_new_comparator(oper_b, &comparator_config, &comparator_b));
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
    mcpwm_generator_config_t generator_config = {};
    generator_config.flags.io_loop_back = false;
    generator_config.flags.io_od_mode = false;
    generator_config.flags.pull_up = false;
    generator_config.flags.pull_down = false;
    
    // –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ A
    generator_config.gen_gpio_num = ESC_A_PIN;
    ESP_ERROR_CHECK(mcpwm_new_generator(oper_a, &generator_config, &generator_a));
    
    // –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ B
    generator_config.gen_gpio_num = ESC_B_PIN;
    ESP_ERROR_CHECK(mcpwm_new_generator(oper_b, &generator_config, &generator_b));
    
    // –ó–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–æ–≤
    ESP_ERROR_CHECK(mcpwm_timer_enable(timer_a));
    ESP_ERROR_CHECK(mcpwm_timer_start_stop(timer_a, MCPWM_TIMER_START_NO_STOP));
    
    ESP_ERROR_CHECK(mcpwm_timer_enable(timer_b));
    ESP_ERROR_CHECK(mcpwm_timer_start_stop(timer_b, MCPWM_TIMER_START_NO_STOP));
}

    //  motor_controller.cpp (—Ç–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏—è setup_generator_actions)
    //  cpp
void MotorController::setup_generator_actions() {
    // –ü–æ–¥–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –¥–ª—è ESP-IDF –º–∞–∫—Ä–æ—Å–æ–≤
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –º–æ—Ç–æ—Ä–∞ A
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(
        generator_a,
        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH),
        MCPWM_GEN_TIMER_EVENT_ACTION_END()
    ));
    
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(
        generator_a,
        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, comparator_a, MCPWM_GEN_ACTION_LOW),
        MCPWM_GEN_COMPARE_EVENT_ACTION_END()
    ));
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –º–æ—Ç–æ—Ä–∞ B
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(
        generator_b,
        MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH),
        MCPWM_GEN_TIMER_EVENT_ACTION_END()
    ));
    
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(
        generator_b,
        MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, comparator_b, MCPWM_GEN_ACTION_LOW),
        MCPWM_GEN_COMPARE_EVENT_ACTION_END()
    ));
    
    #pragma GCC diagnostic pop
}


int MotorController::percent_to_us(int speed_percent) const {
    speed_percent = constrain(speed_percent, 0, 100);
    return ESC_MIN_US + (speed_percent * (ESC_MAX_US - ESC_MIN_US) / 100);
}

uint32_t MotorController::us_to_ticks(int us) const {
    return us * 10; // 10MHz clock = 10 ticks per microsecond
}

bool MotorController::set_motor_speed(char motor_id, int speed_percent) {
    if (speed_percent < 0 || speed_percent > 100) {
        return false;
    }
    
    int pulse_width_us = percent_to_us(speed_percent);
    uint32_t pulse_ticks = us_to_ticks(pulse_width_us);
    
    esp_err_t err;
    if (motor_id == 'A' || motor_id == 'a') {
        err = mcpwm_comparator_set_compare_value(comparator_a, pulse_ticks);
        if (err == ESP_OK) {
            current_speed_a = speed_percent;
            return true;
        }
    } else if (motor_id == 'B' || motor_id == 'b') {
        err = mcpwm_comparator_set_compare_value(comparator_b, pulse_ticks);
        if (err == ESP_OK) {
            current_speed_b = speed_percent;
            return true;
        }
    }
    
    return false;
}

bool MotorController::set_motors_speed(int speed, float ramp_time) {
    if (speed < 0 || speed > 100) {
        Serial.println("–û—à–∏–±–∫–∞: –°–∫–æ—Ä–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 0 –¥–æ 100%");
        return false;
    }
    
    if (ramp_time > 0) {
        ramp_speed(speed, ramp_time);
        return true;
    }
    
    bool success_a = set_motor_speed('A', speed);
    bool success_b = set_motor_speed('B', speed);
    
    if (success_a && success_b) {
        int pulse_us = percent_to_us(speed);
        Serial.printf("–ú–æ—Ç–æ—Ä—ã: %d%% (%dŒºs)\n", speed, pulse_us);
        return true;
    }
    
    return false;
}

void MotorController::ramp_speed(int target_speed, float duration) {
    int start_speed = current_speed_a;
    int steps = max(1, (int)(duration * 10)); // 10 —à–∞–≥–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
    float step_size = (target_speed - start_speed) / (float)steps;
    
    for (int i = 0; i < steps; i++) {
        int intermediate_speed = start_speed + (int)(step_size * (i + 1));
        intermediate_speed = constrain(intermediate_speed, 0, 100);
        
        set_motor_speed('A', intermediate_speed);
        set_motor_speed('B', intermediate_speed);
        
        delay(100);
    }
}

void MotorController::stop_motors(float ramp_time) {
    if (ramp_time > 0) {
        ramp_speed(0, ramp_time);
    } else {
        set_motor_speed('A', 0);
        set_motor_speed('B', 0);
    }
    Serial.println("–ú–æ—Ç–æ—Ä—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã");
}

bool MotorController::start_test_sequence() {
    if (is_test_running) {
        Serial.println("–¢–µ—Å—Ç —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è");
        return false;
    }
    
    Serial.println("=== –ó–ê–ü–£–°–ö –¢–ï–°–¢–û–í–û–ì–û –ü–†–û–ì–û–ù–ê ESC ===");
    Serial.println("1. –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –¥–æ 70%...");
    
    is_test_running = true;
    test_start_time = millis();
    last_report_time = 0;
    
    set_motors_speed(TEST_SPEED_PERCENT, 5.0);
    
    Serial.println("2. –†–∞–±–æ—Ç–∞ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º —É—Ä–æ–≤–Ω–µ (4 –º–∏–Ω—É—Ç—ã)...");
    Serial.printf("–°–∫–æ—Ä–æ—Å—Ç—å: %d%%, –ò–º–ø—É–ª—å—Å: %dŒºs\n", TEST_SPEED_PERCENT, percent_to_us(TEST_SPEED_PERCENT));
    
    return true;
}

void MotorController::stop_test_sequence() {
    if (!is_test_running) return;
    
    Serial.println("3. –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—Ç–æ—Ä–æ–≤...");
    stop_motors(4.0);
    
    is_test_running = false;
    unsigned long test_duration = (millis() - test_start_time) / 1000;
    Serial.printf("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω! –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: %lu —Å–µ–∫—É–Ω–¥\n", test_duration);
}

String MotorController::get_motors_status() const {
    unsigned long elapsed_seconds = is_test_running ? (millis() - test_start_time) / 1000 : 0;
    
    char buffer[200];
    snprintf(buffer, sizeof(buffer), 
        "{\"motor_a\":%d,\"motor_b\":%d,\"pulse_us\":%d,"
        "\"test_running\":%s,\"test_time\":%lu,\"test_total\":%d}",
        current_speed_a, current_speed_b, 
        percent_to_us(current_speed_a),
        is_test_running ? "true" : "false", 
        elapsed_seconds, TEST_DURATION_SEC);
    
    return String(buffer);
}

bool MotorController::is_test_active() const {
    return is_test_running;
}

void MotorController::update() {
    if (!is_test_running) return;
    
    unsigned long current_time = millis();
    unsigned long elapsed_seconds = (current_time - test_start_time) / 1000;
    
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –æ—Ç—á–µ—Ç—ã –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
    if (elapsed_seconds - last_report_time >= 30) {
        Serial.printf("–¢–µ—Å—Ç: %lu/%d —Å–µ–∫\n", elapsed_seconds, TEST_DURATION_SEC);
        last_report_time = elapsed_seconds;
    }
    
    // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
    if (elapsed_seconds >= TEST_DURATION_SEC) {
        stop_test_sequence();
    }
}


//  ==========================================================================================
//  üéØ –û—Å–Ω–æ–≤–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:
//  
//      ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç –∏–º–ø—É–ª—å—Å–æ–≤ - –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞
//      ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–∞–º–∏ - –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—à–∏–±–æ–∫
//      ‚úÖ –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ - –≤—ã–Ω–µ—Å–µ–Ω–æ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
//      ‚úÖ –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ - –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —Å—Ç–∞—Ç—É—Å
//      ‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ - MotorResources –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ—Ç–æ—Ä–∞
//      ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä - –ø—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ —É–¥–∞–ª–µ–Ω–∏—è
//      ‚úÖ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å - –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ JSON
//      ‚úÖ –õ—É—á—à–µ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ - —Å —ç–º–æ–¥–∑–∏ –∏ —É—Ä–æ–≤–Ω—è–º–∏ –≤–∞–∂–Ω–æ—Å—Ç–∏
//  
//  –¢–µ–ø–µ—Ä—å –∫–æ–¥ –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–π, —á–∏—Ç–∞–µ–º—ã–π –∏ –ª–µ–≥–∫–æ —Ä–∞—Å—à–∏—Ä—è–µ–º—ã–π! üöÄ


/*

–£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –æ–±—ã—á–Ω—ã–º PWM (–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞)

–ï—Å–ª–∏ —Å MCPWM Prelude –±—É–¥—É—Ç –ø—Ä–æ–±–ª–µ–º—ã, –≤–æ—Ç –≤–µ—Ä—Å–∏—è —Å –æ–±—ã—á–Ω—ã–º PWM:
cpp

/ * *
 * –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ PWM
 * /

#include <Arduino.h>

class MotorController {
private:
  const int ESC_A_PIN = 25;
  const int ESC_B_PIN = 26;
  const int PWM_FREQ = 50;
  const int PWM_RESOLUTION = 16;
  
  int percent_to_duty(int speed_percent) {
    return map(speed_percent, 0, 100, 3275, 6553); // –î–ª—è 16-bit resolution
  }
  
public:
  MotorController() {
    ledcSetup(0, PWM_FREQ, PWM_RESOLUTION);
    ledcSetup(1, PWM_FREQ, PWM_RESOLUTION);
    ledcAttachPin(ESC_A_PIN, 0);
    ledcAttachPin(ESC_B_PIN, 1);
    set_motors_speed(0);
  }
  
  void set_motors_speed(int speed) {
    int duty = percent_to_duty(speed);
    ledcWrite(0, duty);
    ledcWrite(1, duty);
  }
};

//  –ö–ª—é—á–µ–≤—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:
        –ö–ª—é—á–µ–≤—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è:
    ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è #include <driver/mcpwm_prelude.h>
    ‚úÖ –ù–æ–≤—ã–π API MCPWM —Å handles –≤–º–µ—Å—Ç–æ legacy —Ñ—É–Ω–∫—Ü–∏–π
    ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–∞–º–∏ (—Å–æ–∑–¥–∞–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ)
    ‚úÖ –°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–∞–π–º–µ—Ä–æ–≤ –∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
    ‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —á–µ—Ä–µ–∑ ESP_ERROR_CHECK
–¢–µ–ø–µ—Ä—å –∫–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –¥—Ä–∞–π–≤–µ—Ä MCPWM –±–µ–∑ deprecated –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π!
*/

//-------------------------------------------------------------------------

/*
–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å LEDC PWM

–ï—Å–ª–∏ MCPWM Prelude –≤—Å–µ —Ä–∞–≤–Ω–æ –≤—ã–∑—ã–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã, –≤–æ—Ç –Ω–∞–¥–µ–∂–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å LEDC:
cpp

/ * *
 * –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å LEDC PWM –¥–ª—è ESC
 * /

#include <Arduino.h>

class SimpleMotorController {
private:
  const int ESC_A_PIN = 25;
  const int ESC_B_PIN = 26;
  const int PWM_FREQ = 50;
  const int PWM_RESOLUTION = 16;
  
  int current_speed_a = 0;
  int current_speed_b = 0;
  bool is_test_running = false;
  unsigned long test_start_time = 0;
  
  int percent_to_duty(int speed_percent) {
    // –î–ª—è 16-bit resolution: 0% = 3275, 100% = 6553
    return map(constrain(speed_percent, 0, 100), 0, 100, 3275, 6553);
  }
  
  void ramp_speed(int target_speed, float duration) {
    int start_speed = current_speed_a;
    int steps = duration * 10;
    float step_size = (target_speed - start_speed) / steps;
    
    for (int i = 0; i < steps; i++) {
      int speed = start_speed + step_size * (i + 1);
      set_motors_speed(speed, 0);
      delay(100);
    }
  }

public:
  SimpleMotorController() {
    ledcSetup(0, PWM_FREQ, PWM_RESOLUTION);
    ledcSetup(1, PWM_FREQ, PWM_RESOLUTION);
    ledcAttachPin(ESC_A_PIN, 0);
    ledcAttachPin(ESC_B_PIN, 1);
    set_motors_speed(0);
    Serial.println("SimpleMotorController –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω");
  }
  
  void set_motors_speed(int speed, float ramp_time = 0) {
    speed = constrain(speed, 0, 100);
    
    if (ramp_time > 0) {
      ramp_speed(speed, ramp_time);
    } else {
      int duty = percent_to_duty(speed);
      ledcWrite(0, duty);
      ledcWrite(1, duty);
      current_speed_a = speed;
      current_speed_b = speed;
      Serial.printf("–ú–æ—Ç–æ—Ä—ã: %d%%\n", speed);
    }
  }
  
  void start_test_sequence() {
    Serial.println("–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞...");
    set_motors_speed(70, 5.0);
    is_test_running = true;
    test_start_time = millis();
  }
  
  void update() {
    if (is_test_running && millis() - test_start_time > 240000) {
      set_motors_speed(0, 4.0);
      is_test_running = false;
      Serial.println("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω");
    }
  }
};

SimpleMotorController motor_controller;

–ö–ª—é—á–µ–≤—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è:
    ‚úÖ –ü–æ–ª–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä
    ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω—ã intr_priority = 0 –∏ allow_pd = false
    ‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–µ–π—Å—Ç–≤–∏–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
    ‚úÖ –£–ø—Ä–æ—â–µ–Ω —Ä–∞—Å—á–µ—Ç –∏–º–ø—É–ª—å—Å–æ–≤ –¥–ª—è ESC
    ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å LEDC
–¢–µ–ø–µ—Ä—å –∫–æ–¥ –¥–æ–ª–∂–µ–Ω –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è –±–µ–∑ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π!
–¢–µ–ø–µ—Ä—å –∫–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –¥—Ä–∞–π–≤–µ—Ä MCPWM –±–µ–∑ deprecated –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π!



*/


    //===================================================
    //  6. SD_Handler.cpp - –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏–µ–π
    //===================================================
    //
    //  cpp

#include "SD_Handler.h"
#include <SPI.h>

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
uint32_t SDHandler::last_write_time = 0;
uint32_t SDHandler::last_flush_time = 0;
File SDHandler::data_file;
bool SDHandler::sd_initialized = false;
uint8_t SDHandler::write_buffer[SDHandler::BUFFER_SIZE];
size_t SDHandler::buffer_index = 0;
uint32_t SDHandler::write_count = 0;
uint32_t SDHandler::error_count = 0;




// SD_Handler.cpp  
bool SDHandler::begin() {
    if (!SPIManager::acquireForSD(100)) {
        return false;
    }

    SPIManager::getSPI().beginTransaction(SPISettings(25000000, MSBFIRST, SPI_MODE0));
    bool success = SD.begin(SPI_SD_CS);
    
    if (success) {
        if (!SD.exists("/data")) SD.mkdir("/data");
        char filename[32];
        snprintf(filename, sizeof(filename), "/data/data_%lu.bin", millis());
        data_file = SD.open(filename, FILE_WRITE);
        success = !!data_file;
    }
    
    SPIManager::getSPI().endTransaction();
    SPIManager::release();
    
    return success;
}

        /*  
bool SDHandler::begin() {
    if (!SPIManager::acquireForSD(100)) {
        Serial.println("‚ùå Failed to acquire SPI for SD");
        return false;
    }

    SPIManager::getSPI().beginTransaction(SPISettings(25000000, MSBFIRST, SPI_MODE0));
    sd_initialized = SD.begin(SPI_SD_CS);
    
    if (sd_initialized) {
        // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –¥–∞–Ω–Ω—ã—Ö
        if (!SD.exists("/data")) {
            SD.mkdir("/data");
        }
        
        // –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª —Å timestamp
        char filename[32];
        snprintf(filename, sizeof(filename), "/data/data_%lu.bin", millis());
        data_file = SD.open(filename, FILE_WRITE);
        
        if (!data_file) {
            Serial.println("‚ùå Failed to open data file");
            sd_initialized = false;
        } else {
            Serial.println("‚úÖ SD card and file initialized");
            Serial.printf("üìä Free space: %llu bytes\n", getFreeSpace());
        }
    }
    
    SPIManager::getSPI().endTransaction();
    SPIManager::release();

    last_write_time = millis();
    last_flush_time = millis();
    buffer_index = 0;
    
    return sd_initialized;
}
*/


bool SDHandler::writeData(const SensorData& data) {
    if (!sd_initialized) return false;
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞
    if (!checkFreeSpace()) {
        Serial.println("‚ö†Ô∏è Low disk space, stopping writes");
        sd_initialized = false;
        return false;
    }
    
    uint32_t current_time = millis();
    if ((uint32_t)(current_time - last_write_time) < WRITE_INTERVAL) {
        return false;
    }

    // –ë—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
    if (buffer_index + sizeof(data) > BUFFER_SIZE) {
        if (!flushBuffer()) {
            error_count++;
            return false;
        }
    }
    
    memcpy(&write_buffer[buffer_index], &data, sizeof(data));
    buffer_index += sizeof(data);
    write_count++;
    
    // –ê–≤—Ç–æ-—Å–±—Ä–æ—Å –±—É—Ñ–µ—Ä–∞ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥ –∏–ª–∏ –ø—Ä–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–∏
    if (current_time - last_flush_time > 5000 || buffer_index >= BUFFER_SIZE * 0.8) {
        if (!flushBuffer()) {
            error_count++;
            return false;
        }
    }
    
    last_write_time = current_time;
    return true;
}

bool SDHandler::flushBuffer() {
    if (buffer_index == 0) return true;
    
    if (!SPIManager::acquireForSD(100)) {
        Serial.println("‚ö†Ô∏è Could not acquire SPI for flush");
        return false;
    }

    bool success = false;
    SPIManager::getSPI().beginTransaction(SPISettings(25000000, MSBFIRST, SPI_MODE0));
    
    if (data_file) {
        size_t bytes_written = data_file.write(write_buffer, buffer_index);
        success = (bytes_written == buffer_index);
        
        if (success) {
            data_file.flush();
            Serial.printf("üíæ Flushed %d bytes to SD\n", buffer_index);
        } else {
            Serial.printf("‚ùå Write failed: %d/%d bytes\n", bytes_written, buffer_index);
        }
    }
    
    SPIManager::getSPI().endTransaction();
    SPIManager::release();
    
    buffer_index = 0;
    last_flush_time = millis();
    return success;
}

bool SDHandler::checkFreeSpace() {
    if (!sd_initialized) return false;
    
    uint64_t free_space = getFreeSpace();
    if (free_space < MIN_FREE_SPACE) {
        Serial.printf("‚ö†Ô∏è Low disk space: %llu bytes left\n", free_space);
        return false;
    }
    
    return true;
}

uint64_t SDHandler::getFreeSpace() {
    if (!sd_initialized) return 0;
    
    if (!SPIManager::acquireForSD(50)) return 0;
    
    SPIManager::getSPI().beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    uint64_t total = SD.totalBytes();
    uint64_t used = SD.usedBytes();
    SPIManager::getSPI().endTransaction();
    SPIManager::release();
    
    return (total > used) ? (total - used) : 0;
}

void SDHandler::end() {
    // –°–±—Ä–æ—Å –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –¥–∞–Ω–Ω—ã—Ö –≤ –±—É—Ñ–µ—Ä–µ
    if (buffer_index > 0) {
        flushBuffer();
    }
    
    if (data_file) {
        data_file.close();
        Serial.println("‚úÖ Data file closed");
    }
    
    sd_initialized = false;
    buffer_index = 0;
}

float SDHandler::getSuccessRate() {
    return (write_count > 0) ? (100.0f * (write_count - error_count) / write_count) : 100.0f;
}


//
//===================================================================
//  2. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π SPI_Manager.cpp
//===================================================================
//
//  2. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π SPI_Manager.cpp
//
#include "SPI_Manager.h"

bool SPIManager::spi_busy = false;
uint32_t SPIManager::last_operation_time = 0;
uint8_t SPIManager::current_cs_pin = 0;

bool SPIManager::begin() {
    SPI.begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI);
    pinMode(SPI_ICM_CS, OUTPUT);
    pinMode(SPI_SD_CS, OUTPUT);
    digitalWrite(SPI_ICM_CS, HIGH);
    digitalWrite(SPI_SD_CS, HIGH);
    spi_busy = false;
    return true;
}

bool SPIManager::acquireForICM(uint32_t timeout) {
    return acquireSPI(SPI_ICM_CS, timeout);
}

bool SPIManager::acquireForSD(uint32_t timeout) {
    return acquireSPI(SPI_SD_CS, timeout);
}

void SPIManager::release() {
    if (current_cs_pin != 0) {
        digitalWrite(current_cs_pin, HIGH);
        current_cs_pin = 0;
    }
    spi_busy = false;
}

bool SPIManager::acquireSPI(uint8_t cs_pin, uint32_t timeout) {
    uint32_t start = millis();
    
    while (spi_busy && (millis() - start < timeout)) {
        delay(1); // –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞, –Ω–æ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å vTaskDelay –≤ FreeRTOS
    }
    
    if (spi_busy) return false;
    
    spi_busy = true;
    current_cs_pin = cs_pin;
    digitalWrite(cs_pin, LOW);
    last_operation_time = millis();
    
    return true;
}


//====================================
//  –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π GlobalVars.cpp:
//====================================

#include "GlobalVars.h"

// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
int servoAngles[5] = {90, 90, 90, 90, 0};
int servoTargetAngles[5] = {90, 90, 90, 90, 0};

//===============================================