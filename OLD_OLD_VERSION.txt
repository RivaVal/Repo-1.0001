



//–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø __Set_Full_0005_001   :: –ü–µ—Ä–µ–¥–µ–ª–∞–Ω–Ω—ã–π –ø—Ä–æ–µ–∫—Ç –ø–æ–¥ MODULEMANAGER
//
//–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥ (Receiver)
/**
 * RECEIVER MODULE for Ebyte E49 400T20D
 * –í–µ—Ä—Å–∏—è 1.0
 */


/**
 * @file Receiver_Controller.ino
 * @brief –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –ø—Ä–∏–µ–º–Ω–∏–∫–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–∞–º–æ–ª–µ—Ç–æ–º
 * 
 * –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
 * - –ü—Ä–∏–µ–º –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ –º–æ–¥—É–ª—å EBYTE (LoRa)
 * - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–∞–º–∏ —ç–ª–µ—Ä–æ–Ω–æ–≤ —á–µ—Ä–µ–∑ LEDC
 * - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ—Ç–æ—Ä–∞–º–∏ —á–µ—Ä–µ–∑ MCPWM
 * - –ü–ª–∞–≤–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
 * - –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ —Å –ø—É–ª—å—Ç–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
 * 
 * @author Your Name
 * @date 2025
 */

//  üéØ –≠—Ç–∞–ø 3: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –ø–µ—Ä–µ—Ö–æ–¥—É –Ω–∞ ESP-IDF
//–°–æ–∑–¥–∞–¥–∏–º –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–æ–Ω–Ω—ã–π —Å–ª–æ–π:
// src/platform/arduino_compat.h
//  #pragma once
  /*  
#ifdef ARDUINO
    #include <Arduino.h>
#else
    // –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è ESP-IDF
    #include "freertos/FreeRTOS.h"
    #include "freertos/task.h"
    #include "driver/gpio.h"
    
    #define HIGH 1
    #define LOW 0
    #define INPUT GPIO_MODE_INPUT
    #define OUTPUT GPIO_MODE_OUTPUT
    
    void pinMode(uint8_t pin, uint8_t mode);
    void digitalWrite(uint8_t pin, uint8_t value);
    int digitalRead(uint8_t pin);
    void delay(uint32_t ms);
    uint32_t millis();
#endif
  */

// –°–∏—Å—Ç–µ–º–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
#include <Arduino.h>
#include <stdint.h>
#include <cstddef>

// –ü–µ—Ä–∏—Ñ–µ—Ä–∏–π–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ ESP32
#include "driver/ledc.h"
#include "driver/mcpwm_prelude.h"
#include <SoftwareSerial.h>
#include <HardwareSerial.h>
#include "esp_err.h"

// –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã –º–æ–¥—É–ª—è ICM_20948 –∏ SD Card
#include <SPI.h>
#include <SD.h>
#include "ICM_20948.h"  // –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è ICM-20948
#include <math.h>

// –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
#include "EBYTE.h"
#include "E49_Config.h"
#include "motor_config.h"
#include "E49_Controller.h"

#include "SPI_Manager.h"
#include "ICM_Handler.h"
#include "SD_Handler.h"
#include "Eleron_Controller.h"





// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–æ–¥—É–ª–µ–π
#define DEBUG_MODE
#define MODULE_ICM_20948
#define MODULE_SD_CARD 
  //  #define MODULE_EBYTE
  //  #define EBYTE_MODULE
  //  #define EBYTE_RADIO_MODULE
#define MODULE_LEDC_SERVO
  //  #define MODULE_MCPWM_MOTOR
#define CONTROL_PROJECT_MODULE
#define ESP32FULL 3238

// ==================================================================================
// –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ü–ï–†–ï–ú–ï–ù–ù–´–ï
// ==================================================================================

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è LEDC —ç–ª–µ—Ä–æ–Ω–æ–≤
    // #ifdef LEDC_ELERON_MODULE
#define LEDC_TIMER           LEDC_TIMER_0
#define LEDC_MODE            LEDC_LOW_SPEED_MODE
#define LEDC_DUTY_RES        LEDC_TIMER_8_BIT
#define LEDC_DUTY            (128)
#define LEDC_FREQUENCY       (50)
#define ELERON_UPDATE_DELAY_MS 150
    // #endif

        /*    
–ü–æ—á–µ–º—É —ç—Ç–æ –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ: VSPI ??
    –ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–ø–ø–∞—Ä–∞—Ç–Ω—ã–π SPI - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è - —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω –ø–∏–Ω EBYTE –ó–∞–º–µ–Ω—è–µ—Ç—Å—è
    –í–º–µ—Å—Ç–æ GPIO18 - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–π GPIO21
    –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ - –ø–æ–ª–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
    –°—Ç–∞–±–∏–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞ - –∞–ø–ø–∞—Ä–∞—Ç–Ω—ã–π SPI –Ω–∞–¥–µ–∂–Ω–µ–µ software
        */

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
uint32_t last_success_time = 0;
uint32_t main_loop_counter = 0;
const uint8_t main_loop_counter_m_LIMIT = 150;
uint32_t eleron_test_count = 0;
const uint16_t eleron_max_pause = 150;
uint8_t eleron_count = 0;
uint8_t loop_curent_state = 0;


// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
ICM_20948_SPI myICM;  // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç ICM-20948
File dataFile;         // –§–∞–π–ª –¥–ª—è –∑–∞–ø–∏—Å–∏ –¥–∞–Ω–Ω—ã—Ö
  //  SPIClass hspi(HSPI);   // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –¥–ª—è HSPI
SPIClass vspi(VSPI);   // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –¥–ª—è VSPI

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–ª–∞–¥–∫–∏
ControllerDebug_t _debug = {
    .RC_Debug          = false ,
    .recieve_Debug     = false ,  // –æ–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –Ω–∞–ø–∏—Å–∞–Ω–∏–µ!
    //.receiver_init     = false ,  // –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ init()
    .sender_Debug      = false ,
    .ebyte_Debug       = false ,
    .mcpwm_Debug       = false ,
    .ledc_Debug        = false ,
    .setup_Debug       = true ,
    .loop_Debug        = false ,
    .diod_Debug        = false ,
    .icm20984_Debug    = false ,
    .eleron_Debug      = false ,         // Debug ALL eleron prog
    .slidePot_Debug    = false ,      // –û—Ç–ª–∞–¥–∫–∞ –¥–ª—è SLIDE_POT –ø—Ä–æ–µ–∫—Ç–∞
    .throttle_Debug    = false ,        // Debug ALL Throttle prog   
    .joystick_Debug    = false ,
    .incomedata_Debug  = false ,
    .processdata_Debug    = false ,    // Debug all process function
    .cc               = false 
 };

// –î–∞–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥
DataComSet_t Com;

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
        // const int servoPins[] = {12, 13, 14, 27, 26};
const int servoPins[] = {12, 13, 14, 27, 26};
const ledc_channel_t channels[] = {
    LEDC_CHANNEL_0, 
    LEDC_CHANNEL_1,
    LEDC_CHANNEL_2,
    LEDC_CHANNEL_3,
    LEDC_CHANNEL_4
};

// –£–≥–ª—ã —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
int angles[5] = {0, 0, 0, 0, 0};
int targetAngles[5] = {0, 0, 0, 0, 0};

// –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—ã EBYTE
E49_Controller sender(false);
E49_Controller receiver(true);

// –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
DataComSet_t testData = {
    .preamble = {0xAA, 0x55},
    .packet_id = 0,
    .comUp = 89,
    .comLeft = 89,
    .comThrottle = 127,
    .comParashut = 0,
    .timestamp = 0,
    .comSetAll = 0b00000001,
    .crc8 = 0
};

// ==================================================================================
// –ü–†–û–¢–û–¢–ò–ü–´ –§–£–ù–ö–¶–ò–ô
// ==================================================================================

// EBYTE —Ñ—É–Ω–∫—Ü–∏–∏
void setup_ebyte();
void loop_ebyte();

// MCPWM —Ñ—É–Ω–∫—Ü–∏–∏ (–º–æ—Ç–æ—Ä–∞)
#ifdef MCPWM_MOTOR_MODULE
void setup_mcpwm();
void loop_mcpwm();
void init_motors();
void run_test_sequence();
void smooth_start_motors();
void smooth_stop_motors();
void set_motor_power(uint8_t motor_num, uint8_t power);
#endif

// LEDC —Ñ—É–Ω–∫—Ü–∏–∏ (—ç–ª–µ—Ä–æ–Ω—ã)
#ifdef LEDC_ELERON_MODULE
void setupLEDCTimer();
void setupLEDCChannel(int chan_i, int pin);
void Eleron_LEDCV2_setup();
void proceed_air_command();
void smoothUpdate();
void setServoAngle(int chan_i, int angle);
void Eleron_LEDCV2_loop();
#endif

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
void prepare_income_data();
void prepare_Com_data();

// –ü—Ä–æ—Ç–æ—Ç–∏–ø—ã —Ñ—É–Ω–∫—Ü–∏–π ICM-20948
bool initSDCard();
bool initICM20948();
void calculateEulerAngles(float *quat, float *euler);
void writeBinaryData(const SensorData &data);
void blinkLED(int times, int delayTime);

// ================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==================
EBYTE Transceiver(&Serial2, E49_PIN_M0, E49_PIN_M1, E49_PIN_AUX);


// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–ª–∞—Å—Å–∞ moduleMahager
// –í –æ—Å–Ω–æ–≤–Ω–æ–º .ino —Ñ–∞–π–ª–µ –¥–æ–±–∞–≤—å—Ç–µ:
        //  extern E49_Controller sender;
        //  extern E49_Controller receiver;
        //  extern ModuleTimers_t moduleTimers;
        //ModuleTimers_t moduleTimers;
// –û–±–Ω—É–ª–∏–º –≤—Å–µ —Ç–∞–π–º–µ—Ä—ã –¥–ª—è –Ω–∞—á–∞–ª–∞!        
ModuleTimers_t moduleTimers = {0, 0, 0, 0, 0, 0, 0};

// –ò —Å–æ–∑–¥–∞–π—Ç–µ –æ–±—ä–µ–∫—Ç –ø–æ—Å–ª–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–æ–≤:
        //ModuleManager moduleManager ;
        //moduleManager(false, sender, receiver);

// –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
//  static uint32_t packets_received = 0;
//  static uint32_t packets_ack_sent = 0;
//  static uint32_t last_packet_time = 0;
//  static uint32_t error_count = 0;

// –î–∞–Ω–Ω—ã–µ
//  static DataComSet_t received_data;
//  static AckPacket_t ack_data;


      // –†–∞–±–æ—Ç–∞ —Å –º–æ–¥—É–ª–µ–º –º–æ—Ç–æ—Ä–æ–≤
      //========================================================================================
      //    2. –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª qx_motor_control.ino
      //========================================================================================
    /**
    * @file qx_motor_control.ino
    * @brief –ü—Ä–æ–≥—Ä–∞–º–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è 2 –º–æ—Ç–æ—Ä–∞–º–∏ QX Motor QF(2827) 2227-1800KV
    * 
    * –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
    * - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ –æ–¥–Ω—É —Å—Ç–æ—Ä–æ–Ω—É
    * - –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
    * - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π 4-–º–∏–Ω—É—Ç–Ω—ã–π —Ç–µ—Å—Ç –Ω–∞ 65% –º–æ—â–Ω–æ—Å—Ç–∏
    * - –ó–∞—â–∏—Ç–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –º–æ—â–Ω–æ—Å—Ç–∏
    * - –ü–æ–¥—Ä–æ–±–Ω—ã–π –≤—ã–≤–æ–¥ –≤ Serial –º–æ–Ω–∏—Ç–æ—Ä
    */
    // =============================================
    // ===      –î–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ã  MCPWM        ===
    // =============================================

    static mcpwm_cmpr_handle_t comparator_a = NULL; ///< –ö–æ–º–ø–∞—Ä–∞—Ç–æ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ A
    static mcpwm_cmpr_handle_t comparator_b = NULL; ///< –ö–æ–º–ø–∞—Ä–∞—Ç–æ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ B
    static mcpwm_gen_handle_t generator_a = NULL;   ///< –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ A
    static mcpwm_gen_handle_t generator_b = NULL;   ///< –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ B
    static mcpwm_timer_handle_t timer_a = NULL;     ///< –¢–∞–π–º–µ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ A
    static mcpwm_timer_handle_t timer_b = NULL;     ///< –¢–∞–π–º–µ—Ä –¥–ª—è –º–æ—Ç–æ—Ä–∞ B

    // =============================================
    // ===    –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏      ===
    // =============================================
    // ==================================================================================
    // –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –§–£–ù–ö–¶–ò–ô
    // ==================================================================================
    // ================== –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –§–£–ù–ö–¶–ò–ô ===================================
    // –§—É–Ω–∫—Ü–∏—è –æ–∂–∏–¥–∞–Ω–∏—è –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –º–æ–¥—É–ª—è –ø–æ –ø–∏–Ω—É AUX
    // ================== –§–£–ù–ö–¶–ò–ò RECEIVER ==================
      //===========================================================================================
        void setup_mcpwm  () {
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ—Ä—Ç–∞
          //    Serial. begin(115200);
          //  while(!Serial); // –î–ª—è –ø–ª–∞—Ç —Å USB-Serial
          
          Serial.println("\n\n=== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏ ===");
          Serial.println("–ú–æ–¥–µ–ª—å: QX Motor QF(2827) 2227-1800KV");
          Serial.println("–¢–µ—Å—Ç: 4 –º–∏–Ω—É—Ç—ã –Ω–∞ 65% –º–æ—â–Ω–æ—Å—Ç–∏\n");

          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MCPWM
          init_motors();
          
          // –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
          run_test_sequence();
          
          Serial.println("\n=== –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ _STOP_ ===");
        }

        void loop_mcpwm() {
          // –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
          delay(1000);
        }

        // =============================================
        // ===     –§—É–Ω–∫—Ü–∏–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏    ===
        // =============================================

        /**
        * @brief –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥—Å–∏—Å—Ç–µ–º—ã MCPWM –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏
        * 
        * –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç:
        * - –¢–∞–π–º–µ—Ä—ã —Å –∑–∞–¥–∞–Ω–Ω–æ–π —á–∞—Å—Ç–æ—Ç–æ–π –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ–º
        * - –û–ø–µ—Ä–∞—Ç–æ—Ä—ã –∏ –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä—ã
        * - –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã –®–ò–ú —Å–∏–≥–Ω–∞–ª–æ–≤
        * 
        * @note –í—Å–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è —á–µ—Ä–µ–∑ ESP_ERROR_CHECK
        */
        void init_motors() {
          Serial.println("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MCPWM...");

          // 1. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–∞–π–º–µ—Ä–æ–≤
          mcpwm_timer_config_t timer_config = {
            .group_id = 0,                      // –ì—Ä—É–ø–ø–∞ —Ç–∞–π–º–µ—Ä–æ–≤
            .clk_src = MCPWM_TIMER_CLK_SRC_DEFAULT, // –ò—Å—Ç–æ—á–Ω–∏–∫ —Ç–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            .resolution_hz = PWM_RESOLUTION_HZ,  // –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞

            .count_mode = MCPWM_TIMER_COUNT_MODE_UP,  // –†–µ–∂–∏–º —Å—á–µ—Ç–∞ (–≤–≤–µ—Ä—Ö)
            .period_ticks = PWM_PERIOD_TICKS,    // –ü–µ—Ä–∏–æ–¥ –®–ò–ú

            .intr_priority = 0,       // —è–≤–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            .flags = {
                .update_period_on_empty  = false,      // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_period_on_sync = false,      // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .allow_pd = false                    // –î–æ–±–∞–≤–ª–µ–Ω–æ
                }
              };  // end  timer_config

          // 2. –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–π–º–µ—Ä–æ–≤
          ESP_ERROR_CHECK(mcpwm_new_timer(&timer_config, &timer_a));
          ESP_ERROR_CHECK(mcpwm_new_timer(&timer_config, &timer_b));
          Serial.println("- –¢–∞–π–º–µ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã");

          // 3. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
          mcpwm_operator_config_t operator_config = {
            .group_id = 0, // –¢–∞ –∂–µ –≥—Ä—É–ø–ø–∞, —á—Ç–æ –∏ —É —Ç–∞–π–º–µ—Ä–æ–≤
            .intr_priority = 0,                      // –î–æ–±–∞–≤–ª–µ–Ω–æ
            .flags = {
                .update_gen_action_on_tez  = false,   // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_gen_action_on_tep  = false,   // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_gen_action_on_sync = false,   // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_dead_time_on_tez   = false,   // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_dead_time_on_tep   = false,   // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_dead_time_on_sync  = false    // –î–æ–±–∞–≤–ª–µ–Ω–æ

            }
          }; //end  operator_config

          mcpwm_oper_handle_t oper_a = NULL;
          mcpwm_oper_handle_t oper_b = NULL;
          ESP_ERROR_CHECK(mcpwm_new_operator(&operator_config, &oper_a));
          ESP_ERROR_CHECK(mcpwm_new_operator(&operator_config, &oper_b));
          Serial.println("- –û–ø–µ—Ä–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã");

          // 4. –°–≤—è–∑—ã–≤–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ —Å —Ç–∞–π–º–µ—Ä–∞–º–∏
          ESP_ERROR_CHECK(mcpwm_operator_connect_timer(oper_a, timer_a));
          ESP_ERROR_CHECK(mcpwm_operator_connect_timer(oper_b, timer_b));
          Serial.println("- –û–ø–µ—Ä–∞—Ç–æ—Ä—ã —Å–≤—è–∑–∞–Ω—ã —Å —Ç–∞–π–º–µ—Ä–∞–º–∏");

          // 5. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–æ–≤
          mcpwm_comparator_config_t comparator_config = {
            .intr_priority = 0 ,  //  MCPWM comparator interrupt priority,
            .flags = {
                .update_cmp_on_tez = true,           // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_cmp_on_tep = false,          // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .update_cmp_on_sync = false,         // –î–æ–±–∞–≤–ª–µ–Ω–æ
            }
          };  // end comparator_config
          //  .flags.update_cmp_on_tez = true, // –û–±–Ω–æ–≤–ª—è—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±–Ω—É–ª–µ–Ω–∏–∏ —Ç–∞–π–º–µ—Ä–∞
          //  .flags.update_cmp_on_tep = true, // Whether to update compare value when timer count equals to peak (tep) 
          //  .flags.update_cmp_on_sync = true, // Whether to update compare value on sync event

          ESP_ERROR_CHECK(mcpwm_new_comparator(oper_a, &comparator_config, &comparator_a));
          ESP_ERROR_CHECK(mcpwm_new_comparator(oper_b, &comparator_config, &comparator_b));
          Serial.println("- –ö–æ–º–ø–∞—Ä–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã");

          // 6. –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è (0% duty cycle)
          ESP_ERROR_CHECK(mcpwm_comparator_set_compare_value(comparator_a, 0));
          ESP_ERROR_CHECK(mcpwm_comparator_set_compare_value(comparator_b, 0));

          // 7. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
          mcpwm_generator_config_t generator_config = {
            .gen_gpio_num = MOTOR_A_PWM_PIN, // GPIO –¥–ª—è –º–æ—Ç–æ—Ä–∞ A
            .flags = {
                .invert_pwm   = false,                 // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .io_loop_back = false,               // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .io_od_mode   = false,               // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .pull_up      = false,               // –î–æ–±–∞–≤–ª–µ–Ω–æ
                .pull_down    = false,               // –î–æ–±–∞–≤–ª–µ–Ω–æ
            }
          };  // end generator_config

          ESP_ERROR_CHECK(mcpwm_new_generator(oper_a, &generator_config, &generator_a));
          generator_config.gen_gpio_num = MOTOR_B_PWM_PIN; // GPIO –¥–ª—è –º–æ—Ç–æ—Ä–∞ B
          ESP_ERROR_CHECK(mcpwm_new_generator(oper_b, &generator_config, &generator_b));
          Serial.println("- –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã —Å–æ–∑–¥–∞–Ω—ã");

          // 8. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞:
          // - –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å HIGH –ø—Ä–∏ –æ–±–Ω—É–ª–µ–Ω–∏–∏ —Ç–∞–π–º–µ—Ä–∞
          // - –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å LOW –ø—Ä–∏ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–∏ –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞
          ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(
            generator_a,
            MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
          ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(
            generator_a,
            MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, comparator_a, MCPWM_GEN_ACTION_LOW)));

          ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(
            generator_b,
            MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
          ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(
            generator_b,
            MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, comparator_b, MCPWM_GEN_ACTION_LOW)));
          Serial.println("- –î–µ–π—Å—Ç–≤–∏—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã");

          // 9. –ó–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–æ–≤
          ESP_ERROR_CHECK(mcpwm_timer_enable(timer_a));
          //-----   ESP_ERROR_CHECK(mcpwm_timer_start(timer_a));    //error: 'mcpwm_timer_start' was not declared in this scope
          ESP_ERROR_CHECK(mcpwm_timer_enable(timer_b));
          //----    ESP_ERROR_CHECK(mcpwm_timer_start(timer_b));    // error: 'mcpwm_timer_start' was not declared in this scope
          Serial.println("- –¢–∞–π–º–µ—Ä—ã –∑–∞–ø—É—â–µ–Ω—ã");
          Serial.println("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MCPWM –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!\n");
        }

        // =============================================
        // === –¢–µ—Å—Ç–æ–≤–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å ===
        // =============================================

        /**
        * @brief –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        * 
        * –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–±–æ—Ç—ã:
        * 1. –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –º–æ—Ç–æ—Ä–æ–≤ –¥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
        * 2. –†–∞–±–æ—Ç–∞ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–º —É—Ä–æ–≤–Ω–µ –≤ —Ç–µ—á–µ–Ω–∏–µ 4 –º–∏–Ω—É—Ç
        * 3. –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—Ç–æ—Ä–æ–≤
        * 
        * @note –í–µ—Å—å –ø—Ä–æ—Ü–µ—Å—Å —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ—Ç—Å—è –≤—ã–≤–æ–¥–æ–º –≤ Serial
        */
        void run_test_sequence() {
          Serial.println("=== –ù–∞—á–∞–ª–æ —Ç–µ—Å—Ç–æ–≤–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ ===");
          
          // 1. –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç
          Serial.println("\n [1/3] –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –º–æ—Ç–æ—Ä–æ–≤...");
          smooth_start_motors();
          
          // 2. –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ—Å—Ç
          Serial.println("\n [2/3] –û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ—Å—Ç: 65% –º–æ—â–Ω–æ—Å—Ç–∏ –≤ —Ç–µ—á–µ–Ω–∏–µ 01 –º–∏–Ω—É—Ç");
          set_motor_power(0, TEST_POWER_LEVEL);
          set_motor_power(1, TEST_POWER_LEVEL);
          
          unsigned long test_start = millis();
          while (millis() - test_start < TEST_DURATION_MS) {
            // –í—ã–≤–æ–¥ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –≤—Ä–µ–º–µ–Ω–∏ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            static unsigned long last_print = 0;
            if (millis() - last_print >= 30000) {
              last_print = millis();
              unsigned long remaining = (TEST_DURATION_MS - (millis() - test_start)) / 1000;
              Serial.printf("–û—Å—Ç–∞–ª–æ—Å—å: %lu –º–∏–Ω %lu —Å–µ–∫\n", remaining / 60, remaining % 60);
            }
            delay(100);
          }
          
          // 3. –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
          Serial.println("\n [3/3] –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—Ç–æ—Ä–æ–≤...");
          smooth_stop_motors();
          
          Serial.println("\n=== –¢–µ—Å—Ç–æ–≤–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ! ===");
        }

        // =============================================
        // === –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ—Ç–æ—Ä–∞–º–∏ ===
        // =============================================

        /**
        * @brief –ü–ª–∞–≤–Ω—ã–π —Å—Ç–∞—Ä—Ç –æ–±–æ–∏—Ö –º–æ—Ç–æ—Ä–æ–≤
        * 
        * –ú–æ—Ç–æ—Ä—ã –ø–ª–∞–≤–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞—é—Ç –º–æ—â–Ω–æ—Å—Ç—å –æ—Ç 0% –¥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
        * –∑–∞ –≤—Ä–µ–º—è, —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤ SOFT_START_DURATION_MS
        */
        void smooth_start_motors() {
          Serial.print("–ü–ª–∞–≤–Ω—ã–π —Ä–∞–∑–≥–æ–Ω –¥–æ ");
          Serial.print(TEST_POWER_LEVEL);
          Serial.println("%...");
          
          unsigned long start_time = millis();
          while (millis() - start_time < SOFT_START_DURATION_MS) {
            // –õ–∏–Ω–µ–π–Ω–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –º–æ—â–Ω–æ—Å—Ç–∏
            uint8_t power = map(millis() - start_time, 
                              0, SOFT_START_DURATION_MS, 
                              0, TEST_POWER_LEVEL);
            
            set_motor_power(0, power);
            set_motor_power(1, power);
            delay(10); // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
          }
          
          Serial.println("–ú–æ—Ç–æ—Ä—ã –≤—ã—à–ª–∏ –Ω–∞ —Ä–∞–±–æ—á–∏–π —Ä–µ–∂–∏–º");
        }

        /**
        * @brief –ü–ª–∞–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–±–æ–∏—Ö –º–æ—Ç–æ—Ä–æ–≤
        * 
        * –ú–æ—Ç–æ—Ä—ã –ø–ª–∞–≤–Ω–æ —É–º–µ–Ω—å—à–∞—é—Ç –º–æ—â–Ω–æ—Å—Ç—å –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –¥–æ 0%
        * –∑–∞ –≤—Ä–µ–º—è, —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤ SOFT_START_DURATION_MS
        */
        void smooth_stop_motors() {
          Serial.println("–ü–ª–∞–≤–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ –º–æ—â–Ω–æ—Å—Ç–∏ –¥–æ 0%...");
          
          uint8_t current_power = TEST_POWER_LEVEL;
          unsigned long start_time = millis();
          
          while (millis() - start_time < SOFT_START_DURATION_MS) {
            // –õ–∏–Ω–µ–π–Ω–æ–µ —É–º–µ–Ω—å—à–µ–Ω–∏–µ –º–æ—â–Ω–æ—Å—Ç–∏
            uint8_t power = map(millis() - start_time, 
                              0, SOFT_START_DURATION_MS, 
                              current_power, 0);
            
            set_motor_power(0, power);
            set_motor_power(1, power);
            delay(10); // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
          }
          
          // –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
          set_motor_power(0, 0);
          set_motor_power(1, 0);
          
          Serial.println("–ú–æ—Ç–æ—Ä—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã");
        }

        /**
        * @brief –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ—â–Ω–æ—Å—Ç–∏ –º–æ—Ç–æ—Ä–∞
        * 
        * @param motor_num –ù–æ–º–µ—Ä –º–æ—Ç–æ—Ä–∞ (0 - A, 1 - B)
        * @param power –£—Ä–æ–≤–µ–Ω—å –º–æ—â–Ω–æ—Å—Ç–∏ (0-100%)
        * 
        * @note –§—É–Ω–∫—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –º–æ—â–Ω–æ—Å—Ç—å –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö MIN_DUTY_CYCLE-MAX_DUTY_CYCLE
        */ 
        void set_motor_power(uint8_t motor_num, uint8_t power) 
        {
          // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –º–æ—â–Ω–æ—Å—Ç–∏
          power = constrain(power, MIN_DUTY_CYCLE, MAX_DUTY_CYCLE);
          
          // –†–∞—Å—á–µ—Ç —Ä–∞–±–æ—á–µ–≥–æ —Ü–∏–∫–ª–∞ –≤ —Ç–∏–∫–∞—Ö —Ç–∞–π–º–µ—Ä–∞
          uint32_t duty = (uint32_t)power * PWM_PERIOD_TICKS / 100;

          // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞
          if (motor_num == 0) {
            ESP_ERROR_CHECK(mcpwm_comparator_set_compare_value(comparator_a, duty));
          } else {
            ESP_ERROR_CHECK(mcpwm_comparator_set_compare_value(comparator_b, duty));
          }
        }


/* 
//===================================================================================
//  moduleManager
//===================================================================================
   
void moduleMahager.initializeMotors(){
    init_motors();
}
void initializeEleron(){
  // –ù–∞–¥–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —É–≥–¥—ã –≤ —Å–µ—Ä–µ–¥–∏–Ω—É!

}
initializeSensors(){
  init ICM20948() ;
}
*/


/**
 * @brief –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª—è EBYTE
 */
      //  void setup_ebyte_2_to_1() {
      void setup_ebyte() {
          ebyteStatus _es;    
          
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–¥–∞—Ç—á–∏–∫–∞
          _es = sender.init();
          if (_es != EBYTE_SUCCESS) {
              Serial.print("Failed to initialize sender. Error: ");
              Serial.println(_es);
              while(1) delay(100);
          } else {
              Serial.println("Sender initialized successfully");
          }
          
          // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–µ–º–Ω–∏–∫–∞
          _es = receiver.init();
          if (_es != EBYTE_SUCCESS) {
              Serial.print("Failed to initialize receiver. Error: ");
              Serial.println(_es);
              while(1) delay(100);
          } else {
              Serial.println("Receiver initialized successfully");
          }
          
          sender.enableDebug(true);
          receiver.enableDebug(true);
          
          Serial.println("EBYTE initialization complete");
      }

      /**
      * @brief –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ EBYTE
      */
          //  void loop_ebyte_2_to_1() {
      void loop_ebyte() {
          static uint32_t lastSendTime = 0;
          static uint32_t lastStatsTime = 0;
          static uint8_t consecutiveErrors = 0;
          
          // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∫–∞–∂–¥—ã–µ 500 –º—Å
          if (millis() - lastSendTime > 500) {
              testData.packet_id++;
              testData.timestamp = millis();
              
              ebyteStatus status = sender.sendData(testData);
              if (status != EBYTE_SUCCESS) {
                  consecutiveErrors++;
                  Serial.print("Send error: ");
                  Serial.println(status);
                  
                  if (consecutiveErrors > 3) {
                      Serial.println("Multiple consecutive errors, forcing recovery...");
                      sender.forceRecovery();
                      consecutiveErrors = 0;
                  }
              } else {
                  consecutiveErrors = 0;
              }
              
              lastSendTime = millis();
          }
          
          // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
          receiver.process();
          sender.process();
          
          // –í—ã–≤–æ–¥ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
          if (millis() - lastStatsTime > 5000) {
              Serial.println("Sender stats:");
              sender.printStats();
              
              Serial.println("Receiver stats:");
              receiver.printStats();
              
              lastStatsTime = millis();
          }
          
          delay(10);
      }

    //  #ifdef LEDC_ELERON_MODULE
/**
 * @brief –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–∞–π–º–µ—Ä–∞ LEDC –¥–ª—è —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
 */
      void setupLEDCTimer() {
          ledc_timer_config_t timer_conf = {
              .speed_mode = LEDC_MODE,
              .duty_resolution = LEDC_DUTY_RES,
              .timer_num = LEDC_TIMER,
              .freq_hz = LEDC_FREQUENCY,
              .clk_cfg = LEDC_AUTO_CLK,
              .deconfigure = false
          };
          
          ESP_ERROR_CHECK(ledc_timer_config(&timer_conf));
      }

/**
 * @brief –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞–Ω–∞–ª–∞ LEDC
 * @param chan_i –ò–Ω–¥–µ–∫—Å –∫–∞–Ω–∞–ª–∞
 * @param pin –ü–∏–Ω GPIO
 */
      void setupLEDCChannel(int chan_i, int pin) {
          ledc_channel_config_t channel_conf = {
              .gpio_num = pin,
              .speed_mode = LEDC_MODE,
              .channel = channels[chan_i],
              .intr_type = LEDC_INTR_DISABLE,
              .timer_sel = LEDC_TIMER,
              .duty = 0,
              .hpoint = 0,
              .sleep_mode = LEDC_SLEEP_MODE_NO_ALIVE_NO_PD,
              .flags = {
                  .output_invert = false
              }
          };
          
          ESP_ERROR_CHECK(ledc_channel_config(&channel_conf));
      }

/**
 * @brief –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–ª–µ—Ä–æ–Ω–∞–º–∏
 */
      void Eleron_LEDCV2_setup() {
          setupLEDCTimer();
          
          // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
          for (int i = 0; i < 5; i++) {
              setupLEDCChannel(i, servoPins[i]);
          }
          
          Serial.println("Eleron LEDC system initialized");
      }

/**
 * @brief –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å –ø—É–ª—å—Ç–∞
 */
      void proceed_air_command() {
          // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–µ–ª–µ–≤—ã—Ö —É–≥–ª–æ–≤
          uint8_t tt = constrain(Com.comUp, 0, 180);
          targetAngles[1] = tt; 
          targetAngles[2] = tt; 
          
          tt = constrain(Com.comLeft, 0, 180);
          targetAngles[0] = tt; 
          targetAngles[3] = tt;
      }

/**
 * @brief –ü–ª–∞–≤–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–≥–ª–æ–≤ —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
 */
      void smoothUpdate() {
         // if(_debug.EBYTE_READY) {
              for (int i = 0; i < 5; i++) {
                  if (angles[i] < targetAngles[i]) {
                      angles[i]++;
                  } else if (angles[i] > targetAngles[i]) {
                      angles[i]--;
                  }
                  setServoAngle(i, angles[i]);
              }
         // }
      }

/**
 * @brief –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —É–≥–ª–∞ —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–∞
 * @param chan_i –ò–Ω–¥–µ–∫—Å –∫–∞–Ω–∞–ª–∞
 * @param angle –£–≥–æ–ª (0-180 –≥—Ä–∞–¥—É—Å–æ–≤)
 */
      void setServoAngle(int chan_i, int angle) {
          // –ë—ã—Å—Ç—Ä–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ duty cycle
          uint32_t duty = (angle * 10 + 500) * (1 << LEDC_DUTY_RES) / 20000;
    
          /* 
          // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —É–≥–ª–∞ –≤ —à–∏—Ä–∏–Ω—É –∏–º–ø—É–ª—å—Å–∞
          int pulseWidth = map(angle, 0, 180, 500, 2400);
          
          // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –∑–Ω–∞—á–µ–Ω–∏–µ duty cycle
          uint32_t duty = (pulseWidth * (1 << LEDC_DUTY_RES)) / 20000;
          */
          
          ledc_set_duty(LEDC_MODE, channels[chan_i], duty);
          ledc_update_duty(LEDC_MODE, channels[chan_i]);
          // delay(ELERON_UPDATE_DELAY_MS);     // –£–±—Ä–∞—Ç—å delay()!
      }
      /*
      void setServoAngle(int chan_i, int angle) {
          // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —É–≥–ª–∞ –≤ —à–∏—Ä–∏–Ω—É –∏–º–ø—É–ª—å—Å–∞
          int pulseWidth = map(angle, 0, 180, 500, 2400);
          
          // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –∑–Ω–∞—á–µ–Ω–∏–µ duty cycle
          uint32_t duty = (pulseWidth * (1 << LEDC_DUTY_RES)) / 20000;
          
          ledc_set_duty(LEDC_MODE, channels[chan_i], duty);
          ledc_update_duty(LEDC_MODE, channels[chan_i]);
          delay(ELERON_UPDATE_DELAY_MS);// –≤ setServoAngle() –±–ª–æ–∫–∏—Ä—É–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.
      }
      */
/**
 * @brief –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–ª–µ—Ä–æ–Ω–∞–º–∏
 */
      void Eleron_LEDCV2_loop() {
          if ((millis() - eleron_test_count) < eleron_max_pause) {
              return;
          }
          
          if (eleron_count == 0) {
              proceed_air_command();
          } else if (eleron_count == 1) {
              smoothUpdate();
          }
          
          eleron_count = (eleron_count + 1) % 2;
          eleron_test_count = millis();
      }
        // #endif



/**
 * @brief –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
 */
      void prepare_income_data() {
          // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö
      }

/**
 * @brief –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–º–∞–Ω–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
 */
      void prepare_Com_data() {
          Com.comUp = 0;
          Com.comLeft = 0;
          Com.comThrottle = 3;
          Com.comSetAll = 0;
      }
//----------------------------------------------------------
// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å ICM-20948

bool initICM20948() {
  /*
    Serial.println("Initializing ICM-20948...");
    //  1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∏—Ç–∞–Ω–∏—è –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è 
    checkICMHardware() ;
    //  3.   –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è:
    Serial.println("\t ======== 3.   –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è:  ======");
    void checkResistance();
    //  2. –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–∏
    checkICMConnection_1();
    //  5. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:
    void checkICMConnection_2() ;    
    Serial.println("\t ================checkICMHardware()====================");
    //--------------------------------------------------
    */
    // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º SPI
    // SPI.begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, ICM_CS);
            //    pin Mode(ICM_CS, OUTPUT);
        // digitalWrite(ICM_CS, HIGH); // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º —á–∏–ø
    digitalWrite(E49_ICM_CS, HIGH); // –í–º–µ—Å—Ç–æ ICM_CS

    // 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —á–∏–ø–∞
        // digitalWrite(ICM_CS, LOW);
    digitalWrite(E49_ICM_CS, LOW); // –í–º–µ—Å—Ç–æ ICM_CS
    SPI.transfer(0x00 | 0x80); // –ß—Ç–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞ WHO_AM_I
    uint8_t id = SPI.transfer(0x00);
        //digitalWrite(ICM_CS, HIGH);
    digitalWrite(E49_ICM_CS, HIGH); // –í–º–µ—Å—Ç–æ ICM_CS

    
    Serial.printf("Chip ID: 0x%02X\n", id);
    if (id != 0xEA) {
        Serial.println("Wrong chip ID! Check wiring.");
        return false;
    }
    
    // 3. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É
          //  if (myICM.begin(ICM_CS, SPI) != ICM_20948_Stat_Ok) {
    if (myICM.begin(E49_ICM_CS, SPI) != ICM_20948_Stat_Ok) {
        Serial.println("ICM-20948 initialization failed");
        return false;
    }
    
    Serial.println("ICM-20948 initialized successfully");
    return true;
}

  //  3.   –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è:
void checkResistance() {
    Serial.println("=== RESISTANCE CHECK ===");
    Serial.println("Measure with multimeter:");
    Serial.println("1. Resistance between MISO (GPIO19) and GND");
    Serial.println("   - Should be HIGH resistance (>10kŒ©)");
    Serial.println("2. Resistance between MISO and 3.3V");
    Serial.println("   - Should be HIGH resistance");
    Serial.println("3. If resistance is low - SHORT CIRCUIT!");
}

/*
  //  1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∏—Ç–∞–Ω–∏—è –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
void checkICMHardware() {
    Serial.println("=== HARDWARE CHECK ===");
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∏—Ç–∞–Ω–∏—è –Ω–∞ –ø–∏–Ω–µ CS
              //    pin Mode(ICM_CS, OUTPUT);
    digitalWrite(E49_ICM_CS, HIGH);
    delay(100);
    
    // –ò–∑–º–µ—Ä–µ–Ω–∏–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏—è –Ω–∞ –ø–∏–Ω–µ CS (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å ~3.3V)
    Serial.printf("CS pin voltage: %s\n", digitalRead(E49_ICM_CS) ? "HIGH (3.3V)" : "LOW (0V)");
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –ø–∏–Ω–æ–≤ SPI
    int spiPins[] = {VSPI_MOSI, VSPI_MISO, VSPI_SCLK};
    const char* pinNames[] = {"MOSI (23)", "MISO (19)", "SCLK (18)"};
    
    for (int i = 0; i < 3; i++) {
                  //    pin Mode(spiPins[i], INPUT);
        int state = digitalRead(spiPins[i]);
        Serial.printf("%s: %d\n", pinNames[i], state);
    }
}
*/

/*
  //  5. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:
void checkICMConnection_2() {
    Serial.println("=== ICM-20948 Connection Test ===");
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∏—Ç–∞–Ω–∏—è
            //pin Mode(E49_ICM_CS, OUTPUT);
    digitalWrite(E49_ICM_CS, HIGH);
    delay(100);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–∏
    digitalWrite(E49_ICM_CS, LOW);
    SPI.transfer(0x00 | 0x80); // WHO_AM_I –∑–∞–ø—Ä–æ—Å
    uint8_t response = SPI.transfer(0x00);
    digitalWrite(E49_ICM_CS, HIGH);
    
    Serial.printf("WHO_AM_I response: 0x%02X\n", response);
    if (response == 0xEA) {
        Serial.println("‚úì ICM-20948 connected properly");
    } else {
        Serial.println("‚úó ICM-20948 connection failed");
        Serial.println("Check:");
        Serial.println("- VCC -> 3.3V");
        Serial.println("- GND -> GND");
        Serial.println("- SDA -> GPIO 23 (MOSI)");
        Serial.println("- SDO -> GPIO 19 (MISO)");
        Serial.println("- SCL -> GPIO 18 (SCK)");
        Serial.println("- CS -> GPIO 22");
    }
}

  //  2. –£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤—è–∑–∏
bool checkICMConnection_1() {
    Serial.println("=== DETAILED CONNECTION TEST ===");
    
    // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∏—Ç–∞–Ω–∏—è
            //  pin Mode(E49_ICM_CS, OUTPUT);
    digitalWrite(E49_ICM_CS, HIGH);
    delay(100);
    
    // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SPI
    //    SPI. begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, E49_ICM_CS);
    //    SPI. beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    
    // 3. –ù–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ø—ã—Ç–æ–∫ —á—Ç–µ–Ω–∏—è ID
    for (int attempt = 1; attempt <= 5; attempt++) {
        digitalWrite(E49_E49_ICM_CS, LOW);
        delayMicroseconds(10);
        
        SPI.transfer(0x00 | 0x80); // WHO_AM_I –∑–∞–ø—Ä–æ—Å
        uint8_t id = SPI.transfer(0x00);
        
        delayMicroseconds(10);
        digitalWrite(E49_E49_ICM_CS, HIGH);
        
        Serial.printf("Attempt %d: Chip ID = 0x%02X\n", attempt, id);
        
        if (id == 0xEA) {
            Serial.println("‚úì ICM-20948 found!");
            return true;
        }
        
        delay(100);
    }
    
    Serial.println("‚úó No response from ICM-20948");
    return false;
}
*/

  //  6.   –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ DMP:
// –í —Ñ–∞–π–ª–µ ICM_20948_C.h —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ:
//#define ICM_20948_USE_DMP
// –ó–∞—Ç–µ–º –≤ –∫–æ–¥–µ:
bool initICM20948WithDMP_1() {
    if (myICM.begin(E49_ICM_CS, SPI) != ICM_20948_Stat_Ok) {
        return false;
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ DMP
    if (myICM.initializeDMP() != ICM_20948_Stat_Ok) {
        Serial.println("DMP initialization failed");
        return false;
    }
    
    // –í–∫–ª—é—á–µ–Ω–∏–µ –Ω—É–∂–Ω—ã—Ö —Å–µ–Ω—Å–æ—Ä–æ–≤
    myICM.enableDMPSensor(INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR);
    myICM.enableDMPSensor(INV_ICM20948_SENSOR_ACCELEROMETER);
    
    return true;
}



      /*
      // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å ICM-20948
      bool initSDCard_OLD() {
        if (!SD.begin(E49_E49_SD_CS)) {
          Serial.println("SD Card initialization failed!");
          return false;
        }
        Serial.println("SD Card initialized successfully");
        return true;
      }
      */

      /*
      bool initICM20948_OLD() {
        SPI. begin();  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º SPI
        
        myICM.enableDebugging(Serial); // –û—Ç–∫–ª—é—á–∞–µ–º –æ—Ç–ª–∞–¥–∫—É –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        
        bool initialized = false;
        uint8_t attempts = 0;
        
        while (!initialized && attempts < 5) {
          Serial.print("Attempting to initialize ICM-20948, attempt ");
          Serial.println(attempts + 1);
          
          myICM.begin(E49_ICM_CS, SPI);
          
          if (myICM.status != ICM_20948_Stat_Ok) {
            Serial.println("ICM-20948 initialization failed");
            attempts++;
            delay(1000);
            continue;
          }
    
          // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ DMP
          bool success = true;
          success &= (myICM.initializeDMP() == ICM_20948_Stat_Ok);
          success &= (myICM.enableDMPSensor(INV_ICM20948_SENSOR_GAME_ROTATION_VECTOR) == ICM_20948_Stat_Ok);
          success &= (myICM.enableDMPSensor(INV_ICM20948_SENSOR_ACCELEROMETER) == ICM_20948_Stat_Ok);
          success &= (myICM.enableDMPSensor(INV_ICM20948_SENSOR_GYROSCOPE) == ICM_20948_Stat_Ok);
          success &= (myICM.enableDMPSensor(INV_ICM20948_SENSOR_GEOMAGNETIC_ROTATION_VECTOR) == ICM_20948_Stat_Ok);
          
          if (success) {
            success &= (myICM.setDMPODRrate(DMP_ODR_Reg_Quat6, 0) == ICM_20948_Stat_Ok);
            success &= (myICM.setDMPODRrate(DMP_ODR_Reg_Accel, 0) == ICM_20948_Stat_Ok);
            success &= (myICM.setDMPODRrate(DMP_ODR_Reg_Gyro, 0) == ICM_20948_Stat_Ok);
            success &= (myICM.setDMPODRrate(DMP_ODR_Reg_Gyro_Calibr, 0) == ICM_20948_Stat_Ok);
            success &= (myICM.setDMPODRrate(DMP_ODR_Reg_Cpass, 0) == ICM_20948_Stat_Ok);
            success &= (myICM.setDMPODRrate(DMP_ODR_Reg_Cpass_Calibr, 0) == ICM_20948_Stat_Ok);
          }
          
          if (success) {
            success &= (myICM.enableFIFO() == ICM_20948_Stat_Ok);
            success &= (myICM.enableDMP() == ICM_20948_Stat_Ok);
            success &= (myICM.resetDMP() == ICM_20948_Stat_Ok);
            success &= (myICM.resetFIFO() == ICM_20948_Stat_Ok);
          }
          
          if (success) {
            Serial.println("ICM-20948 DMP initialized successfully");
            initialized = true;
          } else {
            Serial.println("DMP initialization failed");
            attempts++;
            delay(1000);
          }
        }
        
        return initialized;
      } //  end  initICM20948_OLD() 
      */

      // =======================================================
      // –°—á–∏—Ç–∞–µ–º —É–≥–ª—ã –≠–π–ª–µ—Ä–∞ –¥–ª—è –≤—Å–µ—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
      void calculateEulerAngles(float *quat, float *euler) {
        // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∫–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω–∞ –≤ —É–≥–ª—ã –≠–π–ª–µ—Ä–∞ (roll, pitch, yaw)
        float q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3];
        
        // Roll (x-axis rotation)
        float sinr_cosp = 2 * (q0 * q1 + q2 * q3);
        float cosr_cosp = 1 - 2 * (q1 * q1 + q2 * q2);
        euler[0] = atan2(sinr_cosp, cosr_cosp) * 180.0 / M_PI;
        
        // Pitch (y-axis rotation)
        float sinp = 2 * (q0 * q2 - q3 * q1);
        if (fabs(sinp) >= 1)
          euler[1] = copysign(M_PI / 2, sinp) * 180.0 / M_PI;
        else
          euler[1] = asin(sinp) * 180.0 / M_PI;
        
        // Yaw (z-axis rotation)
        float siny_cosp = 2 * (q0 * q3 + q1 * q2);
        float cosy_cosp = 1 - 2 * (q2 * q2 + q3 * q3);
        euler[2] = atan2(siny_cosp, cosy_cosp) * 180.0 / M_PI;
      } // end  calculateEulerAngles(float *quat, float *euler) 

      void writeBinaryData(const SensorData &data) {
        dataFile.write((const uint8_t*)&data, sizeof(SensorData));
      }

      void readICMData() {
        icm_20948_DMP_data_t data;
        myICM.readDMPdataFromFIFO(&data);
        
        if ((myICM.status == ICM_20948_Stat_Ok) || (myICM.status == ICM_20948_Stat_FIFOMoreDataAvail)) {
          SensorData sensorData;
          sensorData.timestamp = millis();
          
          if (data.header & DMP_header_bitmap_Quat6) {
            // –ö–≤–∞—Ç–µ—Ä–Ω–∏–æ–Ω
            float q1 = ((float)data.Quat6.Data.Q1) / 1073741824.0;
            float q2 = ((float)data.Quat6.Data.Q2) / 1073741824.0;
            float q3 = ((float)data.Quat6.Data.Q3) / 1073741824.0;
            float q0 = sqrt(1.0 - (q1 * q1 + q2 * q2 + q3 * q3));
            
            sensorData.quat[0] = q0;
            sensorData.quat[1] = q1;
            sensorData.quat[2] = q2;
            sensorData.quat[3] = q3;
            
            // –†–∞—Å—á–µ—Ç —É–≥–ª–æ–≤ –≠–π–ª–µ—Ä–∞
            calculateEulerAngles(sensorData.quat, sensorData.euler);
          }
          
          if (data.header & DMP_header_bitmap_Accel) {
            // –ê–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä
            sensorData.accel[0] = data.Raw_Accel.Data.X;
            sensorData.accel[1] = data.Raw_Accel.Data.Y;
            sensorData.accel[2] = data.Raw_Accel.Data.Z;
          }
          
          if (data.header & DMP_header_bitmap_Gyro) {
            // –ì–∏—Ä–æ—Å–∫–æ–ø
            sensorData.gyro[0] = data.Raw_Gyro.Data.X;
            sensorData.gyro[1] = data.Raw_Gyro.Data.Y;
            sensorData.gyro[2] = data.Raw_Gyro.Data.Z;
          }
          
          if (data.header & DMP_header_bitmap_Compass) {
            // –ú–∞–≥–Ω–∏—Ç–æ–º–µ—Ç—Ä
            sensorData.mag[0] = data.Compass.Data.X;
            sensorData.mag[1] = data.Compass.Data.Y;
            sensorData.mag[2] = data.Compass.Data.Z;
          }
          
          sensorData.status = data.header;
          
          // –ó–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª
          if (dataFile) {
            writeBinaryData(sensorData);
          }
        }
      }// end readICMData()



            //  –ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ setup():
            //  cpp
bool initSDCard() {
    Serial.println("=== SD CARD DEBUG ===");
    Serial.print("CS pin: "); Serial.println(E49_SD_CS);
    Serial.print("MOSI: "); Serial.println(VSPI_MOSI);
    Serial.print("MISO: "); Serial.println(VSPI_MISO);
    Serial.print("SCK: "); Serial.println(VSPI_SCLK);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∏–Ω–∞ CS
            //      pin Mode(E49_SD_CS, OUTPUT);
    digitalWrite(E49_SD_CS, HIGH);
    Serial.println("CS pin set to HIGH");
    
    // –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ SPI
    //SPI. begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, E49_SD_CS);
    //SPI. beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
    
    // –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ä–∞–∑–Ω—ã–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
    for (int speed = 1000000; speed >= 100000; speed -= 100000) {
        Serial.print("Trying SPI speed: "); Serial.println(speed);
        if (SD.begin(E49_SD_CS, SPI, speed)) {
            Serial.println("Success!");
            return true;
        }
        delay(100);
    }
    
    return false;
}

    //  1. –î–æ–±–∞–≤—å—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–∏–Ω–æ–≤ –≤ setup():
void initializeAllPins() {
    // –ü–∏–Ω—ã EBYTE
    pinMode(E49_PIN_M0, OUTPUT);
    pinMode(E49_PIN_M1, OUTPUT);
    pinMode(E49_PIN_AUX, INPUT);
    
    // SPI –ø–∏–Ω—ã
    pinMode(VSPI_SCLK, OUTPUT);
    pinMode(VSPI_MISO, INPUT);
    pinMode(VSPI_MOSI, OUTPUT);
    pinMode(E49_ICM_CS, OUTPUT);
    pinMode(E49_SD_CS, OUTPUT);
    
    // –ü–∏–Ω—ã —Å–µ—Ä–≤–æ–ø—Ä–∏–≤–æ–¥–æ–≤
    for (int i = 0; i < 5; i++) {
        pinMode(servoPins[i], OUTPUT);
    }
    // –î–ª—è –º–æ—Ç–æ—Ä–Ω—ã—Ö –ø–∏–Ω–æ–≤ GPIO32 –∏ GPIO33 –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:
    // –î–ª—è –º–æ—Ç–æ—Ä–Ω—ã—Ö –ø–∏–Ω–æ–≤ GPIO25 –∏ GPIO26 –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:
    // –ü—Ä–æ—Å—Ç–æ–µ —Ä–µ—à–µ–Ω–∏–µ:
    pinMode(25, OUTPUT);
    pinMode(26, OUTPUT);

    // –°–≤–µ—Ç–æ–¥–∏–æ–¥
    pinMode(LED_PIN, OUTPUT);
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∏–Ω—ã
    pinMode(E49_ICM_INT, INPUT);
    
    Serial.println("All pins initialized");

    digitalWrite(E49_ICM_CS, HIGH);
    digitalWrite(E49_SD_CS, HIGH);
}// end  initializeAllPins()

    //  5. –î–æ–±–∞–≤—å—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∏–Ω–æ–≤ –≤ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ:
void debugPinStates() {
    if (_debug.setup_Debug) {
        Serial.println("=== PIN STATES ===");        
        Serial.println("5. –î–æ–±–∞–≤–∏–ª –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∏–Ω–æ–≤ –≤ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ:");
        int pins[] = {E49_PIN_M0, E49_PIN_M1, E49_PIN_AUX, VSPI_SCLK, VSPI_MISO, VSPI_MOSI, E49_ICM_CS, E49_SD_CS, LED_PIN};
        const char* names[] = {"M0", "M1", "AUX", "SCLK", "MISO", "MOSI", "ICM_CS", "SD_CS", "LED"};
        
        for (int i = 0; i < 9; i++) {
                  //  pin Mode(pins[i], INPUT); // –í—Ä–µ–º–µ–Ω–Ω–æ –∫–∞–∫ –≤—Ö–æ–¥ –¥–ª—è —á—Ç–µ–Ω–∏—è
            Serial.printf("%s: %d\n", names[i], digitalRead(pins[i]));
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ä–µ–∂–∏–º
                    // if (i < 3) pin Mode(pins[i], OUTPUT);
                    //else if (i >= 3 && i <= 6) pin Mode(pins[i], OUTPUT);
                    //else if (i == 7) pin Mode(pins[i], OUTPUT);
                    //else pin Mode(pins[i], OUTPUT);
        }
    }
}

// –°–æ–∑–¥–∞–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
// –°–æ–∑–¥–∞–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
void ICM_SPI_Transaction() {
    digitalWrite(E49_ICM_CS, LOW);
    SPI.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0)); // 10 MHz
    // –ë—ã—Å—Ç—Ä—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
    SPI.endTransaction();
    digitalWrite(E49_ICM_CS, HIGH);
}

// –°–æ–∑–¥–∞–π—Ç–µ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
void SD_SPI_Transaction() {
        //  digitalWrite(SD_CS, LOW);
    digitalWrite(E49_SD_CS, LOW);
    SPI.beginTransaction(SPISettings(25000000, MSBFIRST, SPI_MODE0)); // 25 MHz
    // –ë—ã—Å—Ç—Ä—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
    SPI.endTransaction();
    digitalWrite(E49_SD_CS, HIGH);
}





/**
 * @brief –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏—Å—Ç–µ–º—ã
 */
void setup_OLD() {
    /*    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    if (radioController.init(4, 5, 6)) {
        Serial.println("Radio module initialized");
    }
    
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    uint8_t data[] = {0x01, 0x02, 0x03};
    radioController.sendData(data, 3);
      */
}// end setup_OLD()

//  5. –ì–õ–ê–í–ù–´–ô –§–ê–ô–õ (main.ino)
void setup() {

    //  if (_debug.setup_Debug)  Serial.println("START:Serial. begin(115200)");
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è COM-–ü–æ—Ä—Ç–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ –∏ 
    // –í–´–í–û–î–ê –°–æ–æ–±—â–µ–Ω–∏–π –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–∞–±–æ—Ç—ã
    Serial.begin(115200);
    delay(1000);
    while (!Serial) delay(5);   // –î–ª—è –ø–ª–∞—Ç —Å USB-Serial  –ñ–î–ï–ú –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –ü–æ—Ä—Ç–∞
    if (_debug.setup_Debug)  {
        Serial.println("Serial. begin(115200)--Yet");
    }
    delay(550);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
    SPIManager::begin();
    if (!ICMHandler::begin()) {
        Serial.println("ERROR: ICM initialization failed!");
        while(1) { delay(1000); }
    }
    
    // –û—Å—Ç–∞–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...
    
    //–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è COM-–ü–æ—Ä—Ç–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–µ—Ä–µ–¥–∞—Ç—á–∏–∫–æ–º –¥–∞–Ω–Ω—ã—Ö
    if (_debug.setup_Debug)  Serial.println("START:Serial2.begin( 9600 , SERIAL_8N1, E49_PIN_RX, E49_PIN_TX);");
    Serial2.begin( 9600 , SERIAL_8N1, E49_PIN_RX, E49_PIN_TX);
    while (!Serial2)  delay(5);   // –î–ª—è –ø–ª–∞—Ç —Å USB-Serial  –ñ–î–ï–ú –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –ü–æ—Ä—Ç–∞
    if (_debug.setup_Debug)  {
        Serial.println("Serial2.begin");
    }
    delay (2000) ;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è //  5. –î–æ–±–∞–≤—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∏–Ω–æ–≤ –≤ –æ—Ç–ª–∞–¥–æ—á–Ω–æ–º —Ä–µ–∂–∏–º–µ:
    if (_debug.setup_Debug){ 
        Serial.println("=== System Initialization ===");  
        Serial.println("=initializeAllPins()==");  
    }
    initializeAllPins();
    debugPinStates() ;
    delay(1000);  // –î–∞–π—Ç–µ –ø–∏—Ç–∞–Ω–∏—é —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π –∏ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ SPI
    SPIManager::begin();
    


    //------------------------------------------------------------------
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª—è –¥–∞—Ç—á–∏–∫–∞ ICM@20984 
    if (!ICMHandler::begin()) {
        Serial.println("ICM initialization failed!");
        while(1);
    }
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª—è cSD –∫–∞—Ä—Ç—ã
    if (!SDHandler::begin()) {
        Serial.println("SD initialization failed!");
        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É –±–µ–∑ SD
    }
    

    /*  
    if (_debug.setup_Debug)  Serial.println("\t START: initSDCard()");
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SD –∫–∞—Ä—Ç—ã
    if (!initSDCard()) {
      Serial.println("Failed to initialize SD card!");
      while(1);
    }
    if (_debug.setup_Debug)  {
        Serial.println("initSDCard()");
    }
    */

    delay(1000);  // –î–∞–π—Ç–µ –ø–∏—Ç–∞–Ω–∏—é —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è
    if (_debug.setup_Debug)  Serial.println("\t START: dataFile = SD.open");
    // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –¥–∞–Ω–Ω—ã—Ö
    dataFile = SD.open("/sensor_data.bin", FILE_WRITE);
    if (!dataFile) {
      Serial.println("Failed to create data file!");
      while(1);
    }
    if (_debug.setup_Debug)  {
        Serial.println("dataFile = SD.open");
    }
        //  

    if (_debug.setup_Debug)  Serial.println("\t START: initICM20948()");
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ICM-20948
    if (!initICM20948()) {
      Serial.println("Failed to initialize ICM-20948!");
      while(1);
    }
    if (_debug.setup_Debug)  {
        Serial.println("initICM20948()");
    }

    //--------------------------------------------------------------
        //  #ifdef EBYTE_MODULE
    if (_debug.setup_Debug)  Serial.println("\t START: setup_ebyte()");
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ú–æ–¥—É–ª—è EBYTE
    setup_ebyte();
    if (_debug.setup_Debug)  {
        Serial.println("setup_ebyte()");
    }
        //  #endif

        //  #ifdef MCPWM_MOTOR_MODULE
    //    setup_mcpwm();
    if (_debug.setup_Debug)  {
        Serial.println("setup_mcpwm()");
    }
        //  #endif
    
          //  #ifdef LEDC_ELERON_MODULE
      Eleron_LEDCV2_setup();
    if (_debug.setup_Debug)  {
        Serial.println("Eleron_LEDCV2_setup()");
    }
          // #endif
    
    loop_curent_state = 0;
      Serial.println("======  Setup complete   =======");
}

/**
 * @brief –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –ø—Ä–æ–≥—Ä–∞–º–º—ã
 */
void loop() {
    // –í—ã–¥–µ—Ä–∂–∞—Ç—å –ø–∞—É–∑—É –º–µ–∂–¥—É —Ü–∏–∫–ª–∞–º–∏ LOOP
    if ((millis() - main_loop_counter) < main_loop_counter_m_LIMIT) {
        return;
    }
    // EBYTE
    // –í—ã–¥–µ—Ä–∂–∞—Ç—å –ø–∞—É–∑—É –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏ –º–æ–¥—É–ª—è EBYTE
    if( (millis() -  moduleTimers.lastEbyteTime ) > INTERVAL_EBYTE_PROCESS  ){
      // –ó–Ω—á–∏—Ç —É–∂–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã EBYTE –ú–æ–¥—É–ª—è
      loop_ebyte();
      moduleTimers.lastEbyteTime  = millis() ;
    }

    // MCPWM
    // –í—ã–¥–µ—Ä–∂–∞—Ç—å –ø–∞—É–∑—É –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏ –º–æ–¥—É–ª—è EBYTE
    if( (millis() -  moduleTimers.lastMotorTime ) > INTERVAL_MOTOR_UPDATE ){
      // –ó–Ω—á–∏—Ç —É–∂–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã EBYTE –ú–æ–¥—É–ª—è
      loop_mcpwm();
      moduleTimers.lastMotorTime = millis();
    }

    // ELERON
    // –í—ã–¥–µ—Ä–∂–∞—Ç—å –ø–∞—É–∑—É –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏ –º–æ–¥—É–ª—è EBYTE
    if( (millis() -  moduleTimers.lastEleronTime ) > INTERVAL_ELERON_UPDATE ){
      // –ó–Ω—á–∏—Ç —É–∂–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã EBYTE –ú–æ–¥—É–ª—è
      Eleron_LEDCV2_loop();
    }

    // ICM_20948
    // –í—ã–¥–µ—Ä–∂–∞—Ç—å –ø–∞—É–∑—É –º–µ–∂–¥—É –≤—ã–∑–æ–≤–∞–º–∏ –º–æ–¥—É–ª—è EBYTE
    if( (millis() -  moduleTimers.lastSensorTime ) > INTERVAL_SENSOR_READ ){
      // –ó–Ω—á–∏—Ç —É–∂–µ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã EBYTE –ú–æ–¥—É–ª—è
      readICMData();
      moduleTimers.lastSensorTime = millis();
    }
    main_loop_counter = millis(); // –ù–∞—á–Ω–µ–º —Å—á–∏—Ç–∞—Ç—å –≤—Ä–µ–º—è —Ü–∏–∫–ª—è LOOP


    /*
    switch(loop_curent_state) {
        case 0:
            if(_debug.loop_Debug) {
                Serial.println("Main loop - CASE 0");
            }
            loop_curent_state++;
            break;
            
        case 1:
            if(_debug.loop_Debug) {
                Serial.println("Main loop - CASE 1");
            }
            loop_ebyte();
            loop_curent_state++;
            break;
            
        case 2:
            if(_debug.loop_Debug) {
                Serial.println("Main loop - CASE 2");
            }
            #ifdef LEDC_ELERON_MODULE
                Eleron_LEDCV2_loop();
            #endif
            loop_curent_state++;
            break;
            
        case 3:
          //  if(_debug.EBYTE_Debug && _debug.ELERON_Debug) {
            if(_debug.loop_Debug) {
                Serial.println("Main loop - CASE 3");
            }
            loop_curent_state++;
            break;
            
        case 4:
            if(_debug.loop_Debug) {
                Serial.println("Main loop - CASE 4");
            }

            loop_curent_state = 0;
            break;
    }
    
    main_loop_counter = millis();
    
    // –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–π —Ä–∞–±–æ—Ç–µ
    if ((millis() - main_loop_counter) >= 5000) {
        main_loop_counter = millis();
    }
    */
}



